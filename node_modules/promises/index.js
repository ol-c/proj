module.exports.Promise = Promise;
module.exports.is = is;

//  TODO probably want weak map...
var meta = new Map();

function is(value) {
    return meta.has(value);
}

function Promise() {
    meta.set(this, {});

    var rejected = false;
    var fulfilled = false;
    var when_fulfilled = [];
    var when_rejected = [];
    var fulfill_result;
    var reject_reason;

    this.reject  = function (reason) {
        if (fulfilled) {
            throw new Error('Promise cannot be rejected because it has already been fulfilled');
        }
        else if (rejected) {
            throw new Error('Promise cannot be rejected because it has already been rejected');
        }
        rejected = true;
        reject_reason = reason;
        process.nextTick(function () {
            while (when_rejected.length) {
                when_rejected.shift()(reason);
            }
        });
    };

    this.fulfill = function (result) {
        if (fulfilled) {
            throw new Error('Promise cannot be fulfilled because it has already been fulfilled');
        }
        else if (rejected) {
            throw new Error('Promise cannot be fulfilled because it has already been rejected');
        }
        fulfilled = true;
        fulfill_result = result;
        process.nextTick(function () {
            while (when_fulfilled.length) {
                when_fulfilled.shift()(result);
            }
        });
    }

    this.then = function (on_fulfill, on_reject) {

        if (rejected) {
            process.nextTick(function() {
                on_reject(reject_reason);
            });
        }
        else if (fulfilled) {
            process.nextTick(function () {
                on_fulfill(fulfill_result);
            });
        }
        else {
            if (typeof on_fulfill == 'function') {
                when_fulfilled.push(on_fulfill);
            }
            else throw new Error ('first argument to "then" must be a function to execute on fulfillment of promise');
            
            if (typeof on_reject == 'function') {
                when_rejected.push(on_reject);
            }
            else throw new Error ('second argument to "then" must be a function to execute on rejection of promise');
        }
    }
}
