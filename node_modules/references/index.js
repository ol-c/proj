var resolve_and_execute = require('persist').resolve_and_execute;

//  TODO: probably want to use a weak map here!
var parents = new Map();
var children = new Map();
var names = new Map();

module.exports.reference = create();
module.exports.is = is;
module.exports.resolve = resolve;
module.exports.serializable = get_serializable;

function get_serializable(reference) {
    var path = [];
    var current_reference = reference;
    var name = names.get(current_reference);
    while (name) {
        path.push(name);
        current_reference = parents.get(current_reference);
        name = names.get(current_reference);
    }
    path.reverse();
    return path;
};

function Promise() {
    var rejected = false;
    var fulfilled = false;
    var when_fulfilled = [];
    var when_rejected = [];

    this.reject  = function (reason) {
        rejected = true;
        reject_reason = reason;
    };

    this.fulfill = function (result) {
        fulfilled = true;
        fulfill_result = result;
    }

    this.then = function (on_fulfill, on_reject) {
        if (rejected) on_reject(reason);
        else if (fulfilled) on_fulfill(fulfill_result);
        else {
            if (typeof on_fulfill == 'function') {
                when_fulfilled.push(on_fulfill);
            }
            else throw new Error ('first argument to "then" must be a function to execute on fulfillment of promise');
            
            if (typeof on_reject == 'function') {
                when_rejected.push(on_reject);
            }
            else throw new Error ('second argument to "then" must be a function to execute on rejection of promise');
        }
    }
}

function resolve(reference) {
    var promise = new Promise();

    var path = get_serializable(reference);
    var id = path.shift();

    if (path.length === 0) throw new Error('Cannot resolve reference to nothing');

    var script = 'this.' + path.join('.');
    var operation = {
        type : 'evaluate',
        reference : {id : id},
        script : script
    }

    resolve_and_execute(null, operation, function (err, res) {
        if (err) {
            promise.reject(err);
        }
        else {
            promise.fulfill(res);
        }
    });

    return promise;
}

function is(value) {
    return children.get(value) !== undefined;
};

function create(name) {
    function keys(target) {return [];}

    var apply_arguments;

    function set (target, field, val, receiver) {
        throw new Error('Cannot set values on references');
    }

    function get (target, name, receiver) {
        var child = create(name);
        parents.set(child, proxy);
        children.get(proxy).push(child);
        return child;
    }

    function apply(receiver, args) {
        apply_argunents = args;
    }

    var last_arguments = undefined;
    var resolve = undefined;
    var resolved = false;

    var proxy = Proxy.create({
        get                      : get,
        set                      : set,
        keys                     : keys,
        apply                    : apply,
        getOwnPropertyDescriptor : function (target, name) {},
        getOwnPropertyNames      : function (target) {},
        delete                   : function (name) {},
        freeze                   : function () {},
        seal                     : function () {},
        preventExtensions        : function () {},
        has                      : function () {},
        hasOwn                   : function () {},
        enumerate                : function (target) {},
        construct : function () {}
    });

    children.set(proxy, []);
    names.set(proxy, name);

    //  TODO have return value of proxy adhere to Promise API spec

    return proxy;
}
