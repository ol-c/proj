var persist = require('persist');
var promises = require('promises');

//  TODO: probably want to use a weak map here!
var parents = new Map();
var children = new Map();
var names = new Map();
var execution_arguments = new Map();

var root = create();

module.exports.reference = root;
module.exports.is = is;
module.exports.resolve = resolve;
module.exports.serializable = get_serializable;

function get_source_version(value) {
    if (typeof value === 'string') {
        return '"' + value.replace(/"/gm, '\\"').replace(/\n/gm, '\\n') + '"';
    }
    else if (typeof value === 'number') {
        return '' + value;
    }
    else if (typeof value == 'object' && value instanceof RegExp) {
        return 'new RegExp("' + value + '")';
    }
    else if (is(value)) {
        var source = 'reference';
        var serializable =  get_serializable(value);
        if (serializable.length) {
            source += '.' + serializable.join('.');
        }
        return source;
    }
    else if (Object.prototype.toString.call(val) == '[object Date]') {
        return 'new Date(' + value.getTime() + ')'
    }
    else if (value === undefined) {
        return 'undefined';
    }
    else if (value === null) {
        return 'null';
    }
    else if (typeof value === 'boolean') {
        return value + '';
    }
}

function get_serializable(reference) {
    var path = [];
    var current_reference = reference;
    var name = names.get(current_reference);
    while (name) {
        var args = execution_arguments.get(current_reference);
        if (args) {
           name += '(';
           if (args.length) {
               name += get_source_version(args[0]);
           }
           for (var i=1; i<args.length; i++) {
               name += ', ' + get_source_version(args[i]); //  TODO: need utility to construct source version of primatives better than toString
           }
           name += ')';
        }
        path.push(name);
        current_reference = parents.get(current_reference);
        name = names.get(current_reference);
    }
    path.reverse();
    return path;
};

function resolve(reference) {
    var promise = new promises.Promise();

    var path = get_serializable(reference);

    //  we assume first level container type, not function
    var id = path.shift();

    if (id == undefined) throw new Error('Cannot resolve reference to nothing');

    var script = 'this';

    if (path.length) script += '.' + path.join('.');
    var operation = {
        type : 'evaluate',
        reference : {id : id},
        script : script
    }

    persist.resolve_and_execute(null, operation, function (err, res) {
        if (err) {
            promise.reject(err);
        }
        else if (res.type === 'error') {
            promise.reject(new Error(res.data));
        }
        else if (res.type == 'success') {
            if (res.value.type == 'hashmap') {
                //  create hashmap that serves as a remote version
                var value = persist.create('hashmap', undefined, false);
                for (var field in res.value.data) {
                    value[field] = reference[field];
                }
                promise.fulfill(value);
            }
            else if (res.value.type == 'function') {
                promise.fulfill(persist.scoped(res.value.data));
            }
            else {
                var instance = persist.instance_from_serializable(res.value);
                promise.fulfill(instance);
            }
        }
    });

    return promise;
}

function is(value) {
    return children.get(value) !== undefined;
};

function create(name) {
    function keys(target) {return [];}

    var apply_arguments;

    function set (target, field, val, receiver) {
        throw new Error('Cannot set values on references');
    }

    function get (target, name, receiver) {
        var child = create(name);
        parents.set(child, proxy);
        children.get(proxy).push(child);
        return child;
    }

    

    function call() {
        for (var i=0; i<arguments.length; i++) {
            if (get_source_version(arguments[i]) === undefined) {
                throw new Error('Arguments to referenced functions must be able to be sourcecodable type (yeah, this description needs work...)')
            }
        }
        execution_arguments.set(proxy, arguments);
        return proxy;
    }

    function construct() {
    }

    var last_arguments = undefined;
    var resolve = undefined;
    var resolved = false;

    var proxy = Proxy.createFunction({
        get                      : get,
        set                      : set,
        keys                     : keys,
        apply                    : function apply(receiver, args) {},
        getOwnPropertyDescriptor : function (target, name) {},
        getOwnPropertyNames      : function (target) {},
        delete                   : function (name) {},
        freeze                   : function () {},
        seal                     : function () {},
        preventExtensions        : function () {},
        has                      : function () {},
        hasOwn                   : function () {},
        enumerate                : function (target) {},
        construct : function () {}
    }, call, construct);

    children.set(proxy, []);
    names.set(proxy, name);

    //  TODO have return value of proxy adhere to Promise API spec

    return proxy;
}
