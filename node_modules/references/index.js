var persist = require('persist');
var promises = require('promises');

//  TODO: probably want to use a weak map here!
var parents = new Map();
var children = new Map();
var names = new Map();
var execution_arguments = new Map();
var relative_bindings = new Map(); //  relative values and their current resolutions

var root = create();

module.exports.reference = root;
module.exports.is = is;
module.exports.resolve = resolve;
module.exports.serializable = serializable_from_instance;
module.exports.instance_from_serializable = instance_from_serializable;
module.exports.flatten = flatten;
module.exports.relative = relative;
module.exports.apply = call; //  TODO: resolve naming inconsistency
module.exports.hash = hash;


function hash(reference) {
    var hashed = 'reference';
    for (var i=0; i<reference.length; i++) {
        if (reference[i].type == 'reference') {
            hashed += '["' + reference[i].name + '"]';
        }
        else if (reference[i].type == 'call') {
            hashed += '()'; //  TODO: arguments inside
        }
        else throw new Error('unrecognized type for reference part. must be either reference or call...' + JSON.stringify(reference));
    }
    return hashed;
}

function flatten(reference, callback) {
    var ref = [].concat(reference);
    var field;
    var value;
    //  promise gets executed synchronously
    function check_next() {
        resolve(instance_from_serializable(ref)).then(function (value) {
            if (persist.is(value)) {
                persistant = value;
                return_flat();
            }
            else if (ref.length) {
                field = ref.pop();
                check_next();
            }
            else {
                callback(new Error('error resolving the reference'))
            }
        }, function (error) {
            callback(error);
        });
    }

    function return_flat() {
        var flattened = [];

        if (persistant === undefined) {
            throw new Error('could not resolve reference to be flattened')
        }
        else {
            flattened.push({
                'type' : 'reference',
                'name' : persist.identify(persistant)
            });
        }

        if (field) {
            //  TODO: copy field so no funny business goes down in it somewhere else
            flattened.push(field);
        }
        callback(null, flattened);
    }
    check_next();
}

function instance_from_serializable(serialized) {
    var path = serialized;
    var instance = root;
    //  TODO: respect relative resolutions
    for (var i=0; i<path.length; i++) {
        if (i==0 && path[0].resolution) {
            instance = relative(path[0].name, path[0].resolution);
        }
        else if (path[i].type == 'call') {
            // instance from serializable for each argument
            var argument_references = [];
            var args = {};
            for (var j=0; j<path[i].arguments.length; j++) {
                var name = 'args.a' + j;
                args['a' + j] = persist.instance_from_serializable(path[i].arguments[j]);
                argument_references.push(name);
            }
            //  eval with all arguments;
            eval('instance = instance(' + argument_references.join(', ') + ')');
        }
        else {
            instance = instance[path[i].name];
        }
    }
    return instance;
}

function get_source_version(value) {
    if (typeof value === 'string') {
        return '"' + value.replace(/"/gm, '\\"').replace(/\n/gm, '\\n') + '"';
    }
    else if (typeof value === 'number') {
        return '' + value;
    }
    else if (typeof value == 'object' && value instanceof RegExp) {
        return 'new RegExp("' + value + '")';
    }
    else if (is(value)) {
        var source = 'reference';
        var serializable =  serializable_from_instance(value);
        if (serializable.length) {
            source += '.' + serializable.join('.');
        }
        return source;
    }
    else if (Object.prototype.toString.call(value) == '[object Date]') {
        return 'new Date(' + value.getTime() + ')'
    }
    else if (value === undefined) {
        return 'undefined';
    }
    else if (value === null) {
        return 'null';
    }
    else if (typeof value === 'boolean') {
        return value + '';
    }
}

function serializable_from_instance(reference) {
    var path = [];
    var current_reference = reference;
    var name = names.get(current_reference);
    var relative_binding = relative_bindings.get(current_reference);
    var ref;
    while (name) {
        ref = {};
        ref.name = name;
        ref.relative = relative_binding;
        var args = execution_arguments.get(current_reference);
        if (args) {
            ref.type = "call";
            ref.arguments = [];
            for (var i=0; i<args.length; i++) {
                ref.arguments.push(persist.serializable_from_instance(args[i]));
            }
        }
        else {
            ref.type = "reference";
        }
        path.push(ref);
        current_reference = parents.get(current_reference);
        name = names.get(current_reference);
        relative_binding = relative_bindings.get(current_reference);
    }
    path.reverse();
    return path;
};

function relative(relative_name, resolved_name) {
    var relative_reference = root[resolved_name];

    relative_bindings.set(relative_reference, relative_name);
    
    return relative_reference;
}

function resolve(reference, synchronous) {

    var promise = new promises.Promise();

    //  TODO: flag to not serialize arguments...
    var path = serializable_from_instance(reference);


    //  we assume first level container type, not function
    var id = path.shift().name;

    if (id == undefined) throw new Error('Cannot resolve reference to nothing');

    var script = 'this';

    //  construct source code to call and return value
    for (var i=0; i<path.length; i++) {
        var ref = path[i];
            
        if (ref.type == "call") {
            var source_args = [];
            for (var j=0; j<ref.arguments.length; j++) {
                source_args.push(get_source_version(persist.instance_from_serializable(ref.arguments[j])));
            }
            script += '(' + source_args.join(', ') + ')';
        }
        else {
            name = ref.name;
            script += '["' +  ref.name + '"]';
        }
    }

    var local = persist.get(id);
    if (local) {
        var value = persist.scoped(script, local);
        if (synchronous) return value;
        else promise.fulfill(value);
    }
    else if (synchronous) {
        throw new Error('cannot synchronously resolve external reference');
    }
    else {

        var operation = {
            type : 'evaluate',
            reference : [{name : id, type : 'reference'}],
            agents : 'root',
            script : script
        }

        persist.resolve_and_execute(null, operation, function (err, res) {
            if (err) {
                promise.reject(err);
            }
            else if (res.type === 'error') {
                promise.reject(new Error(res.data));
            }
            else if (res.type == 'success') {
                if (res.value.type == 'hashmap') {
                    //  create hashmap that serves as a remote version
                    //  where all fields are references
                    var value = persist.create('hashmap', undefined, false);
                    for (var field in res.value.data) {
                        value[field] = reference[field];
                    }
                    promise.fulfill(value);
                }
                else if (res.value.type == 'function') {
                    promise.fulfill(persist.scoped(res.value.data));
                }
                else {
                    var instance = persist.instance_from_serializable(res.value);
                    promise.fulfill(instance);
                }
            }
        });
    };

    return promise;
}

function is(value) {
    return children.get(value) !== undefined;
};


function call(reference, args) {
    for (var i=0; i<args.length; i++) {
        if (get_source_version(args[i]) === undefined) {
            throw new Error('Arguments to referenced functions must be able to be sourcecodable type (yeah, this description needs work...)')
        }
    }
    //  create name of "" is an execution proxy
    var execution_proxy = get(reference, "*");
    execution_arguments.set(execution_proxy, args);
    return execution_proxy;
}

function get (reference, name) {
    var child = create(name);
    parents.set(child, reference);
    children.get(reference).push(child);
    return child;
}



function create(name) {
    function keys(target) {return [];}

    var apply_arguments;

    function set (target, field, val, receiver) {
        throw new Error('Cannot set values on references');
    }
    var last_arguments = undefined;
    var resolve = undefined;
    var resolved = false;

    var proxy = Proxy.createFunction({
        get : function (target, name, receiver) {
            return get(proxy, name);
        },
        set                      : set,
        keys                     : keys,
        apply                    : function apply(receiver, args) {},
        getOwnPropertyDescriptor : function (target, name) {},
        getOwnPropertyNames      : function (target) {},
        delete                   : function (name) {},
        freeze                   : function () {},
        seal                     : function () {},
        preventExtensions        : function () {},
        has                      : function () {},
        hasOwn                   : function () {},
        enumerate                : function (target) {},
        construct                : function () {}
    },
    function () {/* call function */ return call(proxy, arguments);},
    function () {/* construct function */});

    children.set(proxy, []);
    names.set(proxy, name);

    //  TODO have return value of proxy adhere to Promise API spec

    return proxy;
}
