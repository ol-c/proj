var hash_reference = require('./hash_reference');
var watched_references = require('./watched_references');
var serializable_from_instance = require('./serializable_from_instance');
var get_time = require('./get_time');
var get_type = require('./get_type');
var auth = require('auth');
var domain = require('domain');
var context_authorizations = require('./context_authorizations');

var updates_pending = new Map();

//  TODO: can have send to watching, which serializas values before sending, or pass to watching that receives serialized values and passes to watching
//  update operations in resolve_and_execute.js start with serialized values so will want to pass
//  set operations in get_persistant_proxy.js start with instances so want to use send
function send_to_watching(context, reference, value) {
    //  TODO: only use the last 2 parts of a reference to send updates to watching, as those are the only consistent uniquely identifying attributes
    var hashed_ref = hash_reference(reference.slice(-2));
    var watching = watched_references[hashed_ref];
    function send(watcher) {
        if (updates_pending.get(watcher) == undefined) {
            updates_pending.set(watcher, {});
        }
        return function () {
            if (watching) {
                //  assume value has already been serialized here
                var serialized = value;
                //  if can get its type, then it is not serialized yet
                if (get_type(value) !== undefined) {
                    serialized = serializable_from_instance(value, reference);
                }
                //  overwrite existing update function if exists
                updates_pending.get(watcher)[hashed_ref] = {
                    serialized_value : serialized,
                    time : get_time()
                };
                process.nextTick(function () {
                    //  only execute update function once per process tick
                    var update = updates_pending.get(watcher)[hashed_ref];
                    if (update) {
                        //  TODO: send original time along
                        var update = JSON.stringify({
                            type : 'update',
                            reference : reference,
                            time : update.time,
                            value : update.serialized_value,
                            token : update.time
                        });
                        delete updates_pending[hashed_ref];
                        //  if context is also watching this reference, it does not need to receive the update
                        if (context != watcher && watcher.open) {
                            watcher.respond.call(watcher, '"""'  + update);
                        }
                    }
                });
            }
        };
    }
    //  reuse domain from watch operation

    if (watching) {
        for (var i=0; i<watching.length; i++) {
            if (context != watching[i]) {
                var d = context_authorizations.get(watching[i]);
                if (d) d.run(send(watching[i]));
            }
        }
    }
}

module.exports = send_to_watching;
