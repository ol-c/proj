var hash_reference = require('./hash_reference');
var watched_references = require('./watched_references');
var serializable_from_instance = require('./serializable_from_instance');
var get_time = require('./get_time');
var get_type = require('./get_type');
var auth = require('auth');
var domain = require('domain');
var context_authorizations = require('./context_authorizations');
var references = require('references');

var updates_pending = new Map();

var flattens_started = 0;
var flattens_done = 0;

//  TODO: can have send to watching, which serializas values before sending, or pass to watching that receives serialized values and passes to watching
//  update operations in resolve_and_execute.js start with serialized values so will want to pass
//  set operations in containers.js start with instances so want to use send
function send_to_watching(context, reference, value) {

    //  IMPORTANT: reference must be pre-flattened...

    var hashed_ref = hash_reference(reference);
    var watching = watched_references[hashed_ref];

    //  reuse domain from watch operation
    if (watching) {
        for (var i=0; i<watching.length; i++) {
            if (context != watching[i]) {
                var d = context_authorizations.get(watching[i]);
                if (d) d.run(send(watching[i]));
            }
        }
    }

    function send(watcher) {
        if (updates_pending.get(watcher) == undefined) {
            updates_pending.set(watcher, {});
        }
        return function () {
            //  assume value has already been serialized here
            var serialized = value;
            //  if can get its type, then it is not serialized yet
            if (get_type(value) !== undefined) {
                serialized = serializable_from_instance(value, reference);
            }
            //  overwrite existing update function if exists
            updates_pending.get(watcher)[hashed_ref] = {
                serialized_value : serialized,
                time : get_time()
            };
            //  only execute update function once per process tick
            var update = updates_pending.get(watcher)[hashed_ref];
            if (update) {
                //  TODO: send original time along
                var update = JSON.stringify({
                    type : 'update',
                    reference : reference,
                    time : update.time,
                    value : update.serialized_value,
                    token : update.time
                });
                delete updates_pending[hashed_ref];
                //  if context is also watching this reference, it does not need to receive the update
                if (context != watcher) {
                    queued.push({watcher : watcher, update : update});
                }
            }
        };
    }
}

var queued = [];

function send_next() {
    //  TODO: combine all to be sent to same watcher into one network call
    while (queued.length) {
        var next = queued.shift();
        var watcher = next.watcher;
        var update = next.update;
        if (watcher.open) {
            watcher.respond.call(watcher, '"""'  + update);
        }
    }
    setTimeout(send_next, 10);
}

setTimeout(send_next, 10);

module.exports = send_to_watching;
