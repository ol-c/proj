var hash_reference = require('./hash_reference');
var watched_references = require('./watched_references');
var serializable_from_instance = require('./serializable_from_instance');
var get_time = require('./get_time');
var get_type = require('./get_type');
var domain = require('domain');

var updates_pending = {};

//  TODO: can have send to watching, which serializas values before sending, or pass to watching that receives serialized values and passes to watching
//  update operations in resolve_and_execute.js start with serialized values so will want to pass
//  set operations in get_persistant_proxy.js start with instances so want to use send
function send_to_watching(context, reference, value) {
    function send() {
        var hashed_ref = hash_reference(reference);
        var watching = watched_references[hashed_ref];
        if (watching) {
            //  assume value has already been serialized here
            var serialized = value;
            //  if can get its type, then it is not serialized yet
            if (get_type(value) !== undefined) {
                serialized = serializable_from_instance(value, reference);
            }
            //  overwrite existing update function if exists
            updates_pending[hashed_ref] = {
                serialized_value : serialized,
                time : get_time()
            }
            process.nextTick(function () {
                //  only execute update function once per process tick
                var update = updates_pending[hashed_ref];
                if (update) {
                    //  TODO: send original time along
                    var update = JSON.stringify({
                        type : 'update',
                        reference : reference,
                        time : update.time,
                        value : update.serialized_value,
                        token : update.time
                    });
                    delete updates_pending[hashed_ref];
                    for (var i=0; i<watching.length; i++) {
                        //  if context is also watching this reference, it does not need to receive the update
                        if (context != watching[i] && watching[i].open) {
                            watching[i].respond.call(watching[i], '"""'  + update);
                        }
                    }
                }
            });
        }
    }
    //  TODO: reuse domain from watch operation
    var d = domain.create();
    d.name = "watcher's domain"
    d.run(send);
}

module.exports = send_to_watching;
