module.exports = resolve_and_execute;

var net = require('net');
var persist = require('persist');
var promises = require('promises');

var proxies = require("./proxies");
var instance_from_serializable = require("./instance_from_serializable");
var responses = require('./responses');
var host_resolver = require('./host_resolver');
var JSONprotocol = require('./json_protocol');
var serializable_from_instance = require('./serializable_from_instance');
var hash_reference = require('./hash_reference');
var watched_references = require('./watched_references');
var get_type = require('./get_type');
var meta = require('./meta');
var scoped = require('./scoped');
var send_to_watching = require('./send_to_watching');
var create = require('./create');
var context_authorizations = require('./context_authorizations');
var authorize = require('authorize');
var domain = require('domain');

function resolve_and_execute(context, operation, callback) {
    // TODO: add followed path portion to reference so we
    //       can check circular references between processes
    // TODO: check authorization of requesters in reference
    var reference = operation.reference;
    var value = proxies[reference.id];
    if (operation.type == 'update') {
        //  updates come from instances this instance is watching,
        //  so we pass updates to instances that watch this one
        update_operation(context, reference, operation.value);
    }
    else if (responses[operation.token] || operation.type == 'success' || operation.type == 'error') {
        if (responses[operation.token]) {
            responses[operation.token](null, operation);
            delete responses[operation.token];           
        }
    }
    else if (value) {
        var value_parent = null;
        if (reference.internal) {
            var internal = reference.internal.split('.');
            value_parent = reference.id;
            while (internal.length) {
                var type = get_type(value);
                if (type == 'hashmap' || type == 'list') {
                    value_parent = meta.get(value).id;
                    value = value[internal.shift()];
                    if (value === undefined && internal.length) {
                        callback('invalid reference');
                        return;
                    }
                }
                else if (type == 'reference') {
                    resolve_and_execute(context, {
                        type : operation.type,
                        reference : {
                            id       : value.id,
                            internal : internal.join('.')
                        },
                        token : operation.token,
                        agents : operation.agents.concat([root_name]),
                    }, callback);
                    return;
                }
            }
        }
        //  perform proper operation
        if (operation.type == 'source reference') {
            reference_operation(value, operation, reference, callback);
        }
        else if (operation.type == 'evaluate') {
            evaluate_operation(value, operation, reference, callback);
        }
        //  watch operations must be passed to the proper server 
        else if (operation.type == 'watch') {
            watch_operation(context, value, operation, reference, callback);
        }
        else callback('invalid operation type: ' + operation.type);
    }
    else {
        resolve_and_execute_external(context, operation, callback);
    }
}

function reference_operation(value, operation, reference, callback) {
    //  TODO: check if agents of operation have access
    var ref_str = reference.id;
    if (value !== null && value === undefined) callback('invalid reference');
    else {
        var serializable = serializable_from_instance(value, reference);
        serializable.token = operation.token;
        callback(null, serializable);
    }
}

function evaluate_operation(value, operation, reference, callback) {
    //  if value is function, execute and return
    var type = get_type(value);
    if (type == 'hashmap') {
        var returned;
        try {
            // try to get the return value, but since script may be too many lines this will error out
            var trimmed = operation.script.replace(/(;|\s)*$/g, '');
            returned = scoped(operation.script, value, 'agent evaluating');
            //  if returned is a promise, wait for the promise before calling back!!!!
            function respond(returned) {
                var returned_reference;
                if (persist.is(returned)) {
                    returned_reference = {
                        id : meta.get(returned).id
                    };
                }
                else if (get_type(returned) == undefined && typeof returned == 'object') {
                    returned_reference = {
                        id : returned.id
                    };
                    returned = create('hashmap', undefined, true);
                    //  TODO: fill in fields
                }
                var res = {
                    type : "success",
                    token : operation.token,
                    reference : reference,
                    agents : operation.agents,
                    value : serializable_from_instance(returned, returned_reference)
                };
                callback(null, res);
            }
            if (promises.is(returned)) {
                returned.then(respond, function (reason) {
                    callback(reason.stack + "");
                });
            }
            else {
                respond(returned);
            }
        }
        catch (error) {
            callback(error.stack + "");
        }
    }
    else callback('scripts must be evaluated in the context of a persistant object');
}

function watch_operation(context, value, operation, reference, callback) {
    var hashed_reference = hash_reference(reference);
    var watching = watched_references[hashed_reference];
    if (watching == undefined) {
        watching = [];
        watched_references[hashed_reference] = watching;
    }
    var already_watching = false;

    for (var i=0; i<watching.length; i++) {
        if (watching[i] == context) {
            already_watching = true;
            break;
        }
    }

    //  create domain so when we watch we can check permissions through send_to_watching.js and authorize module
    if (!already_watching) {
        var d = domain.create();
        d.authorizations = authorize.authorizations();
        context_authorizations.set(context, d);
        console.log('set the domain with proper authrizations...')
        watching.push(context);
    }
    else {
        console.log('already watching....')
    }

    callback(null, {
        type : 'success',
        token : operation.token,
        agents : operation.agents,
        reference : reference
    });
}

function update_operation(context, reference, value) {
    //  callback not needed because we do not need to acknowledge
    //  an update operation to the sender
    send_to_watching(context, reference, value);
}

var connections = {};

function resolve_and_execute_external(context, operation, callback) {
    host_resolver.get(operation.reference.id, function (err, data) {
        if (err) callback('error occurred resolving host for reference');
        else if (data) {
            //  make TCP request to proper host
            var host_reference = data.host + ':' + data.port;
            if (connections[host_reference] == undefined) {
                var client = net.connect(data.port, data.host, function () {
                    client.write('"""' + JSON.stringify(operation));
                });
                var external_requester = 'value for external requester';
                client.on('data', JSONprotocol(client, client.write, external_requester));
                client.on('end', function () {
                    //  TODO: clean up connections
                });
                connections[host_reference] = client;
            }
            else {
                connections[host_reference].write('"""' + JSON.stringify(operation));
            }
            if (operation.type == 'watch') {
                var hashed_reference = hash_reference(operation.reference);
                var watching = watched_references[hashed_reference];
                if (watching == undefined) {
                    watching = [];
                    watched_references[hashed_reference] = watching;
                }
                var already_watching = false;

                for (var i=0; i<watching.length; i++) {
                    if (watching[i] == context) {
                        already_watching = true;
                        break;
                    }
                }

                //  create domain to attach authorizations for watcher
                if (!already_watching) {
                    var d = domain.create();
                    d.authorizations = authorize.authorizations();
                    context_authorizations.set(context, d);
                    watching.push(context);
                }

                callback(null, {
                    type : 'success',
                    token : operation.token,
                    agents : operation.agents,
                    reference : operation.reference
                });
            }
            else responses[operation.token] = callback;
        }
        else callback('could not resolve host for reference');
    });
}
