module.exports = resolve_and_execute;

var net = require('net');
var persist = require('persist');
var promises = require('promises');

var proxies = require("./proxies");
var instance_from_serializable = require("./instance_from_serializable");
var responses = require('./responses');
var host_resolver = require('./host_resolver');
var JSONprotocol = require('./json_protocol');
var serializable_from_instance = require('./serializable_from_instance');
var hash_reference = require('./hash_reference');
var watched_references = require('./watched_references');
var get_type = require('./get_type');
var meta = require('./meta');
var scoped = require('./scoped');
var send_to_watching = require('./send_to_watching');
var create = require('./create');
var context_authorizations = require('./context_authorizations');
var auth = require('auth');
var domain = require('domain');
var references = require('references');

function resolve_and_execute(context, operation, callback) {
    // TODO: add followed path portion to reference so we
    //       can check circular references between processes
    // TODO: check authorization of requesters in reference
    var reference = operation.reference;
    var local = persist.get(reference[0].name);
    if (operation.type == 'update') {
        //  updates come from instances this instance is watching,
        //  so we pass updates to instances that watch this one
        update_operation(context, reference, operation.value);
    }
    else if (responses[operation.token] || operation.type == 'success' || operation.type == 'error') {
        if (responses[operation.token]) {
            responses[operation.token](null, operation);
            delete responses[operation.token];           
        }
    }
    else if (local) {
        var resolvable = references.resolve(references.instance_from_serializable(reference));

        resolvable.then(function (value) {
            //  perform proper operation
            if (operation.type == 'source reference') {
                reference_operation(value, operation, reference, callback);
            }
            else if (operation.type == 'evaluate') {
                evaluate_operation(value, operation, reference, callback);
            }
            //  watch operations must be passed to the proper server 
            else if (operation.type == 'watch') {
                watch_operation(context, value, operation, reference, callback);
            }
            else callback('invalid operation type: ' + operation.type);
        }, function (error) {
            callback(error);
        });
    }
    else {
        resolve_and_execute_external(context, operation, callback);
    }
}

function reference_operation(value, operation, reference, callback) {
    //  TODO: check if agents of operation have access
    if (value !== null && value === undefined) callback('invalid reference');
    else {
        var serializable = serializable_from_instance(value, reference);
        serializable.token = operation.token;
        callback(null, serializable);
    }
}

function evaluate_operation(value, operation, reference, callback) {
    //  if value is function, execute and return
    var type = get_type(value);
    if (type == 'hashmap') {
        var returned;
        try {
            // try to get the return value, but since script may be too many lines this will error out
            var trimmed = operation.script.replace(/(;|\s)*$/g, '');
            returned = scoped(operation.script, value, 'agent evaluating');
            //  if returned is a promise, wait for the promise before calling back!!!!
            function respond(returned) {
                var returned_reference;
                if (persist.is(returned)) {
                    returned_reference = [{
                        type : 'reference',
                        name : meta.get(returned).id
                    }];
                }
                else if (get_type(returned) == undefined && typeof returned == 'object') {
                    returned_reference = [{
                        type : 'reference',
                        name : returned.id
                    }];
                    returned = create('hashmap', undefined, true);
                    //  TODO: fill in fields
                }
                var res = {
                    type : "success",
                    token : operation.token,
                    reference : reference,
                    agents : operation.agents,
                    value : serializable_from_instance(returned, returned_reference)
                };
                callback(null, res);
            }
            if (promises.is(returned)) {
                returned.then(respond, function (reason) {
                    callback(reason + "");
                });
            }
            else {
                respond(returned);
            }
        }
        catch (error) {
            callback(error);
        }
    }
    else callback('scripts must be evaluated in the context of a persistant object');
}

function watch_operation(context, value, operation, reference, callback) {
    var hashed_reference = hash_reference(reference);
    var watching = watched_references[hashed_reference];
    if (watching == undefined) {
        watching = [];
        watched_references[hashed_reference] = watching;
    }
    var already_watching = false;

    for (var i=0; i<watching.length; i++) {
        if (watching[i] == context) {
            already_watching = true;
            break;
        }
    }

    //  create domain so when we watch we can check permissions through send_to_watching.js and authorize module
    if (!already_watching) {
        var d = domain.create();
        d.authorizations = auth.authorizations();
        context_authorizations.set(context, d);
        watching.push(context);
    }

    callback(null, {
        type : 'success',
        token : operation.token,
        agents : operation.agents,
        reference : reference
    });
}

function update_operation(context, reference, value) {
    //  callback not needed because we do not need to acknowledge
    //  an update operation to the sender
    send_to_watching(context, reference, value);
}

var connections = {};

function resolve_and_execute_external(context, operation, callback) {
    var agent = undefined;
    if (operation.agents) agent = operation.agents[0];
    host_resolver.get(operation.reference[0].name, agent, function (err, data) {
        //  !!!!!!!!!  scope for auth.authorizations broken here
        if (err) callback(err);
        else if (data) {
            //  make TCP request to proper host
            var host_reference = data.host + ':' + data.port;
            //  add current agents before sending the operation
            var agents = operation.agents;
            if (connections[host_reference] == undefined) {
                var client = net.connect(data.port, data.host, function () {
                    operation.agents = agents;
                    client.write('"""' + JSON.stringify(operation));
                });
                var external_requester = 'value for external requester';
                client.on('data', JSONprotocol(client, client.write, external_requester));
                client.on('end', function () {
                    //  TODO: clean up connections
                });
                connections[host_reference] = client;
            }
            else {
                operation.agents = agents;
                connections[host_reference].write('"""' + JSON.stringify(operation));
            }
            if (operation.type == 'watch') {
                operation.agents = agents;
                var hashed_reference = hash_reference(operation.reference);
                var watching = watched_references[hashed_reference];
                if (watching == undefined) {
                    watching = [];
                    watched_references[hashed_reference] = watching;
                }
                var already_watching = false;

                for (var i=0; i<watching.length; i++) {
                    if (watching[i] == context) {
                        already_watching = true;
                        break;
                    }
                }

                //  create domain to attach authorizations for watcher
                if (!already_watching) {
                    var d = domain.create();
                    d.authorizations = auth.authorizations();
                    context_authorizations.set(context, d);
                    watching.push(context);
                }

                callback(null, {
                    type : 'success',
                    token : operation.token,
                    agents : operation.agents,
                    reference : operation.reference
                });
            }
            else responses[operation.token] = callback;
        }
        else callback('no host for reference');
    });
}
