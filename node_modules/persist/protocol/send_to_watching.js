//var hash_reference = require('../hash_reference');
var watched_references = require('./watched_references');
var serializable_from_instance = require('../serialization/serializable_from_instance');
var get_time = require('../history/get_time');
var get_type = require('../meta/get_type');
var auth = require('auth');
var domain = require('domain');
var context_authorizations = require('./context_authorizations');
var references = require('references');

var updates_pending = new Map();
var queued = [];
var synchronous_update_queue = [];

//  TODO: can have send to watching, which serializas values before sending, or pass to watching that receives serialized values and passes to watching
//  update operations in resolve_and_execute.js start with serialized values so will want to use pass
//  set operations in containers.js start with instances so want to use send

//  TODO: allow for compiling of updates done in same synchronous call
function send_to_watching(context, reference, value) {

    //  IMPORTANT: reference must be pre-flattened...

//    var hashed_ref = hash_reference(reference);
//    var watching = watched_references[hashed_ref];

    var h = references.hash(reference);

    //  TODO: not sure if this will allow non-synchronous updates to be combined...
    if (synchronous_update_queue.length == 0) {
        process.nextTick(combine_synchronous_updates);
    }
    synchronous_update_queue.push({
        hashed_ref : h,
        reference : reference,
        watching : watched_references[h],
        value : value
    });

    //  we want to be able to combine updates that were generated synchronously
    //  (like strings, so clients get the expected update after they execute a script that modifies the string)
    //  this also helps with performance, both network and client
    function combine_synchronous_updates() {
        //  TODO: compile operations that can be compiled
        //            example: string operations that were triggered at same synchronous time
        //            with no other updates triggered between can be safely combined
        while (synchronous_update_queue.length) {
            var update = synchronous_update_queue.shift();
            //  reuse domain from watch operation
            if (update.watching) {
                for (var i=0; i<update.watching.length; i++) {
                    if (context != update.watching[i]) {
                        var d = context_authorizations.get(update.watching[i]);
                        if (d) d.run(send(update.watching[i], update.hashed_ref, update.value, update.reference));
                    }
                }
            }
        }
    }

    function send(watcher, hashed_ref, value, reference) {
        if (updates_pending.get(watcher) == undefined) {
            updates_pending.set(watcher, {});
        }
        return function () {
            //  assume value has already been serialized here
            var serialized = value;
            //  if can get its type, then it is not serialized yet
            if (get_type(value) !== undefined) {
                serialized = serializable_from_instance(value, reference);
            }
            //  overwrite existing update function if exists
            updates_pending.get(watcher)[hashed_ref] = {
                serialized_value : serialized,
                time : get_time()
            };
            //  only execute update function once per process tick
            var update = updates_pending.get(watcher)[hashed_ref];
            if (update) {
                //  TODO: send original time along
                var update = JSON.stringify({
                    type : 'update',
                    reference : reference,
                    time : update.time,
                    value : update.serialized_value,
                    token : update.time
                });
                delete updates_pending[hashed_ref];
                //  if context is also watching this reference, it does not need to receive the update
                if (context != watcher) {
                    queued.push({watcher : watcher, update : update});
                }
            }
        };
    }
}


function send_next() {
    //  TODO: combine all to be sent to same watcher into one network call
    while (queued.length) {
        var next = queued.shift();
        var watcher = next.watcher;
        var update = next.update;
        if (watcher.open) {
            watcher.respond.call(watcher, update + '"""');
        }
    }
    setTimeout(send_next, 10);
}

setTimeout(send_next, 10);

module.exports = send_to_watching;
