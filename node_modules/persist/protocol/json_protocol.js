var domain = require('domain');
var resolve_and_execute = require('./resolve_and_execute');
var error_report = require('../errors');
var auth = require('auth');

var profile = require('profile');

module.exports = JSONprotocol;


//  handle request over JSON protocol
function JSONprotocol(context, respond) {
    var end = profile.start('JSONprotocol');
    //  TODO: gaurd against circular reference
    context.respond = respond;
    function send(response) {
        respond.call(context, response + '"""');
    }
    var buffer = "";
    function handler(data) {
        //  sometimes multiple writes are lumped into data
        //  """ cannot occur in JSON so we append it to all
        //  JSON requests
        //  """ also terminates the complete ness of a message
        data = buffer + data;
        var operations = (data + '').split('"""');

        //  if last operation isn't terminated, add it to buffer
        if (data.slice(data.length - 3) !== '"""') {
            buffer = operations.pop();
        }
        else {
            buffer = "";
        }

        while (operations.length) {
            var operation = operations.shift();
            if (operation != '') {
                process_operation(context, operation, send);
            }
        }
    }

    end();
    return handler;
}

var client_tokens = {};

function process_operation(context, operation, send) {
    var end = profile.start('process_operation');

    try {
        operation = JSON.parse(operation);
        //  TODO: verify reference validity
    }
    catch (error) {
        console.log('error occurred parsing');
        require('fs').writeFileSync('test.txt', operation);
        //send(error_report('invalid JSON formatting received', true));
    }
    var d = domain.create();

    d.on('error', function (error) {
        var reference = operation.reference;
        var error_rep = error_report(error, false, reference);
        error_rep.token = operation.token;
        send(JSON.stringify(error_rep));
    });

    d.run(function () {
        var reference = operation.reference;
        //  only trust agent lists from TCP connections (those are under the security layer)
        if (context.type != 'websocket') {
            if (operation.agents) {
                for (var i=0; i<operation.agents.length; i++) {
                    auth.associate(operation.agents[i]);
                }
            }
        }
        else if (context.session.id) {
            auth.associate(auth.decode(context.session.id));
        }
        else {
            throw new Error('Session Cookie required for access');
        }
        operation.agents = auth.authorizations();

        function done(error, value) {
            if (error) {
                value = error_report(error, false, reference);
            }
            value.token = operation.token;
            send(JSON.stringify(value));
        }

        resolve_and_execute(context, operation, done);
    });

    end();
}
