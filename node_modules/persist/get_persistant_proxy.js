module.exports = get_persistant_proxy;

var meta = require("./meta");
var get_type = require("./get_type");
var get_time = require("./get_time");
var send_to_watching = require("./send_to_watching");
var records = require("./records");
var proxies = require('./proxies');
var events = require('./events');
var scoped = require('./scoped');
var serializable_from_instance = require('./serializable_from_instance');
var create = require('./create');
var auth = require('auth');

var hashmaps = require('./hashmaps');
var lists    = require('./lists');
var sets     = require('./sets');

function get_persistant_proxy(type, id) {

    var valid_types = {
        'hashmap' : true,
        'list'    : true,
        'set'     : true
    };

    if (type !== undefined) {
        if (valid_types[type]) {
            //  valid type
        }
        else throw new Error(type + ' is an invalid type for a persistant object');
    }

    //  if type is undefined, it can be set later

    var hash = {};

    var permissions;

    var type_saved = false;

    function set_field(target, field, val, receiver) {
        console.log(field);
        if (field == 'type' && !type_saved) {
            //  save the type for later, but don't actualy set it
            if (valid_types[val]) {
                type = val;
                type_saved = true;
                var time = get_time();
                var operation = 'set';
                meta.get(proxy).type = type;
                if (meta.get(proxy).loaded && meta.get(proxy).backup) {
                    records.save({
                        time      : time,
                        id        : id,
                        operation : operation,
                        field     : field,
                        value     : serializable_from_instance(val, [{name: id, type : 'reference'}])
                    });
                }
            }
            else throw new Error(val + ' is invalid type');
        }
        else if (type == 'list') {
            list_set_field(target, field, val, receiver);
        }
        else if (type == 'set') {
            set_set_field(target, field, val, receiver);
        }
        else if (type == 'hashmap') {
            hashmap_set_field(target, field, val, receiver);
        }
        else {
            throw new Error('type must be first field set');
        }
    }

    var proxy = Proxy.create({
        getOwnPropertyDescriptor : function (target, name) {
            return hash[name];
        },
        getOwnPropertyNames : function (target) {
            var properties = [];
            for (var property in hash) {
                if (hash.hasOwnProperty(property)) {
                    properties.push(property);
                }
            }
            return properties;
        },
        delete : function (name) {
            proxy[name] = undefined;
        },
        freeze : function () {},
        seal : function () {},
        preventExtensions : function () {},
        has : function () {},
        hasOwn : function () {},
        get : function (target, name, receiver) {
            if (meta.get(proxy).loaded) {
                auth.authorize('get', permissions, name);
            }
            return hash[name];
        },
        set : set_field,
        enumerate : function (target) {
            var properties = [];
            for (var property in hash) {
                if (hash.hasOwnProperty(property)) {
                    properties.push(property);
                }
            }
            return properties;
        },
        keys : function (target) {
            var properties = [];
            for (var property in hash) {
                if (hash.hasOwnProperty(property)) {
                    properties.push(property);
                }
            }
            return properties;
        },
        apply : function () {},
        construct : function () {}
    });

    meta.set(proxy, {
        id              : id,
        hash            : hash,
        loaded          : false,
        unloading       : false,
        field_settings  : {
            frozen : {}
        },
        type            : type,
        pending_records : [],
        dependencies    : [],
        onload          : [],
    });

    proxies[id] = proxy;

    events.trigger('control', id);

    function hashmap_set_field(target, field, val, receiver) {
        if (meta.get(proxy).field_settings.frozen[field] === true) {
            throw new Error('"' + field + '" is not editable');
        }

        if (meta.get(proxy).loaded) {
            auth.authorize('set', permissions, field, val);
        }

        //  type will be undefined for a loading persistant object
        //  checking meta ensures persistant objects are allowed
        if (get_type(val)) {
            var time = get_time();
            var operation = 'set';
            if (meta.get(proxy).loaded && meta.get(proxy).backup) {
                records.save({
                    time      : time,
                    id        : id,
                    operation : operation,
                    field     : field,
                    value     : serializable_from_instance(val, [{name: id, type : 'reference'}])
                });
            }
            if (val !== undefined) hash[field] = val;
            else delete hash[field];

            if (field == 'permissions') {
                permissions = val;
            }

            var self_reference = [{name : id, type : 'reference'}];
            var field_reference = self_reference.concat([{
                name : field,
                type : 'reference'
            }]);

            //  send to watching this field and this proxy
            send_to_watching(null, self_reference, proxy);
            send_to_watching(null, field_reference, val);
        }
        else {
            throw new Error((typeof val) +  ' not supported in persistant object');
        }
    }

    var list = [];

    function list_set_field(target, field, val, receiver) {
        if (isNaN(parseInt(field)) && field !== 'render' && field !== 'permissions' ) {
            throw new Error('List indices must be numeric');
        }

        if (meta.get(proxy).field_settings.frozen[field] === true) {
            throw new Error('"' + field + '" is not editable');
        }

        if (meta.get(proxy).loaded) {
            auth.authorize('set', permissions, field, val);
        }

        //  type will be undefined for a loading persistant object
        //  checking meta ensures persistant objects are allowed
        if (get_type(val)) {
            var time = get_time();
            var operation = 'set';
            if (meta.get(proxy).loaded && meta.get(proxy).backup) {
                records.save({
                    time      : time,
                    id        : id,
                    operation : operation,
                    field     : field,
                    value     : serializable_from_instance(val, [{name: id, type : 'reference'}])
                });
            }
            list[field] = val;

            if (field == 'permissions') {
                permissions = val;
            }

            var self_reference = [{name : id, type : 'reference'}];
            var field_reference = self_reference.concat([{
                name : field,
                type : 'reference'
            }]);

            //  send to watching this field and this proxy
            send_to_watching(null, self_reference, proxy);
            send_to_watching(null, field_reference, val);
        }
    }

    function set_set_field() {
        throw new Error('Cannot set fields on a set.');
    }


    return proxy;
}
