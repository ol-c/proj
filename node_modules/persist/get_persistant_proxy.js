var meta = require("./meta");
var get_type = require("./get_type");
var get_time = require("./get_time");
var send_to_watching = require("./send_to_watching");
var save_record = require("./save_record");
var proxies = require('./proxies');
var events = require('./events');
var scoped = require('./scoped');
var serializable_from_instance = require('./serializable_from_instance');

function get_persistant_proxy(id) {

    var hash = {};

    function set_field(target, field, val, receiver) {
        var type = meta.get(proxy).type;

        var LIST = type == 'list';
        var HASH = type == 'hashmap';

        if (LIST && !isNumber(field)) {
            throw new Error('arrays are only indexed with numeric values');
        }

        var type = get_type(val);
        var persistant = meta.has(val)

        //  type will be undefined for a loading persistant object
        //  checking meta ensures persistant objects are allowed
        if (persistant || type) {
            var time = get_time();
            var operation = 'set';
            var value = val + '';

            if (persistant) {
                value = meta.get(val).id;
                meta.get(proxy).dependencies.push(val);
            }
            else if (type == 'function') {
                //  allows us to add any function and savely have it scoped
                val = scoped(value);
            }
            else if (type == 'file')      value = value.url;
            else if (type == 'reference') value = value.path;
            else if (type == 'date')      value = val.toJSON();

            if (meta.get(proxy).loaded) {
                save_record({
                    time      : time,
                    id        : id,
                    operation : operation,
                    field     : field,
                    type      : type,
                    value     : value
                });
            }
            if (LIST) {
                list[field] = val;
            }
            else if (HASH) {
                if (val !== undefined) hash[field] = val;
                else delete hash[field];
            }
            var reference = {
                id : id,
                internal : field
            };
            //  send to watching this field
            send_to_watching(null, reference, serializable_from_instance(val));
            //  send to watching this other proxy
            send_to_watching(null, {id:id}, serializable_from_instance(proxy));
        }
        else {
            throw new Error((typeof val) + ' not supported in persistant object');
        }
    }

    var proxy = Proxy.create({
        getOwnPropertyDescriptor : function (target, name) {
            return hash[name];
        },
        getOwnPropertyNames : function (target) {
            var properties = [];
            for (var property in hash) {
                if (hash.hasOwnProperty(property)) {
                    properties.push(property);
                }
            }
            return properties;
        },
        delete : function (name) {
            proxy[name] = undefined;
        },
        freeze : function () {},
        seal : function () {},
        preventExtensions : function () {},
        has : function () {},
        hasOwn : function () {},
        get : function (target, name, receiver) {
            return hash[name];
        },
        set : set_field,
        enumerate : function (target) {
            var properties = [];
            for (var property in hash) {
                if (hash.hasOwnProperty(property)) {
                    properties.push(property);
                }
            }
            return properties;
        },
        keys : function (target) {
            var properties = [];
            for (var property in hash) {
                if (hash.hasOwnProperty(property)) {
                    properties.push(property);
                }
            }
            return properties;
        },
        apply : function () {},
        construct : function () {}
    });

    meta.set(proxy, {
        id              : id,
        hash            : hash,
        loaded          : false,
        unloading       : false,
        pending_records : [],
        dependencies    : [],
        onload          : [],
    });

    proxies[id] = proxy;

    events.trigger('control', id);

    return proxy;
}

module.exports = get_persistant_proxy;
