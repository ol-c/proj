module.exports.create_container = create_container;
module.exports.get_container_for = get_container_for;

var meta = require("./meta");
var get_type = require("./get_type");
var get_time = require("./get_time");
var send_to_watching = require("./send_to_watching");
var records = require("./records");
var proxies = require('./proxies');
var events = require('./events');
var scoped = require('./scoped');
var serializable_from_instance = require('./serializable_from_instance');
var create = require('./create');
var auth = require('auth');
var util = require('util');
var promises = require('promises');

var object_to_container = new Map();

function get_container_for(object) {
    return object_to_container.get(object);
}

function reference_to_value(value) {
    var container_field;
    if (value == undefined) return undefined;
    var container = object_to_container.get(value);
    if (meta.get(container).type == 'hashmap') {
        for (var field in container) {
            if (container[field] == value) {
                container_field = field;
                break;
            }
        }
    }
    else if (meta.get(container).type == 'list') {
        for (var i=0; i<container.length; i++) {
            if (container[i] == value) {
                container_field = i + '';
                break;
            }
        }
    }
    else {
        throw new Error('can only get reference to a value in a hashmap or a list');
    }
    return [{
        name : meta.get(container).id,
        type : 'reference'
    },{
        type : 'reference',
        name : container_field
    }]
}

function create_container(type, id) {

    var valid_types = {
        'hashmap' : true,
        'list'    : true,
        'promise' : true
    };

    if (type !== undefined) {
        if (valid_types[type]) {
            //  valid type
        }
        else throw new Error(type + ' is an invalid type for a persistant object');
    }

    var promise = new promises.Promise();
    var fulfill_functions = [];
    var reject_functions = [];

    //  if type is undefined, it can be set later

    var hash = {};

    var permissions;

    function set_field(target, field, val, receiver) {
        var type = meta.get(proxy).type;
        if (type == 'list') {
            list_set_field(target, field, val, receiver);
        }
        else if (type == 'set') {
            set_set_field(target, field, val, receiver);
        }
        else if (type == 'hashmap') {
            hashmap_set_field(target, field, val, receiver);
        }
        else if (type == 'promise') {
            throw new Error('cannot set field on a promise');
        }
        else {
            throw new Error('invalid container type');
        }
        object_to_container.set(val, proxy);
    }

    var list_functions = {
        concat : list_concat,
        indexOf : list_indexOf,
        lastIndexOf : list_lastIndexOf,
        pop : list_pop,
        push : list_push,
        reverse : list_reverse,
        shift : list_shift,
        slice : list_slice,
        sort : list_sort,
        splice : list_splice,
        unshift : list_unshift
    };

    function get_field(target, name, receiver) {
        var type = meta.get(proxy).type;
        if (type == 'hashmap') {
            if (meta.get(proxy).loaded) {
                auth.authorize('get', permissions, name);
            }
            return hash[name];
        }
        else if (type == 'list') {
            if (!isNaN(parseInt(name))) {
                return list[name];
            }
            else if (name == 'length') {
                return list.length;
            }
            else if (list_functions[name]) {
                return list_functions[name];
            }
            else {
                throw new Error('List has no property "' + name + '"');
            }
        }
        else if (type == 'promise') {
            if (name == 'fulfill') {
                return function () {
                    //  if proxy is completely loaded, then save and execute call
                    if (meta.get(proxy).loaded) {
                        var args = [];
                        for (var i=0; i<arguments.length; i++) {
                            args.push(serializable_from_instance(arguments[i]));
                        }
                        records.save({
                            time : get_time(),
                            id : id,
                            operation : 'call',
                            field : 'fulfill',
                            arguments : args
                        });
                        promise.fulfill.apply(promise, arguments);
                    };
                };
            }
            else if (name == 'reject') {
                return function () {
                    //  if proxy is completely loaded, then save and execute call
                    promise.reject.apply(promise, arguments);
                    if (meta.get(proxy).loaded) {
                        var args = [];
                        for (var i=0; i<arguments.length; i++) {
                            args.push(serializable_from_instance(arguments[i]));
                        }
                        records.save({
                            time : get_time(),
                            id : id,
                            operation : 'call',
                            field : 'reject',
                            arguments : args
                        });
                    }
                };
            }
            else if (name == 'then') {
                return function (on_fulfill, on_reject) {
                    //  TODO: arguments can be a reference to the function
                    //  or the function itself
                    //  (from which we construct the reference)
                    var fulfill_ref = reference_to_value(on_fulfill);
                    var reject_ref = reference_to_value(on_reject);
                    if (meta.get(proxy).loaded) {
                        //  TODO: replace references with actual values...
                        promise.then.apply(promise, arguments);
                        records.save({
                            time : get_time(),
                            id : id,
                            operation : 'call',
                            field : 'then',
                            arguments : [
                                {type : 'reference', data : fulfill_ref},
                                {type : 'reference', data : reject_ref}
                            ]
                        });
                    }
                }
            }
            else {
                return undefined;
            }
        }
    }

    var proxy = Proxy.create({
        getOwnPropertyDescriptor : function (target, name) {
            return hash[name];
        },
        getOwnPropertyNames : function (target) {
            var properties = [];
            for (var property in hash) {
                if (hash.hasOwnProperty(property)) {
                    properties.push(property);
                }
            }
            return properties;
        },
        delete : function (name) {
            proxy[name] = undefined;
        },
        freeze : function () {},
        seal : function () {},
        preventExtensions : function () {},
        has : function () {},
        hasOwn : function () {},
        get : get_field,
        set : set_field,
        enumerate : function (target) {
            var properties = [];
            for (var property in hash) {
                if (hash.hasOwnProperty(property)) {
                    properties.push(property);
                }
            }
            return properties;
        },
        keys : function (target) {
            var properties = [];
            for (var property in hash) {
                if (hash.hasOwnProperty(property)) {
                    properties.push(property);
                }
            }
            return properties;
        },
        apply : function () {},
        construct : function () {}
    });

    meta.set(proxy, {
        id              : id,
        hash            : hash,
        loaded          : false,
        unloading       : false,
        field_settings  : {
            frozen : {}
        },
        type            : type,
        pending_records : [],
        dependencies    : [],
        onload          : [],
    });

    proxies[id] = proxy;

    events.trigger('control', id);

    function hashmap_set_field(target, field, val, receiver) {
        if (meta.get(proxy).field_settings.frozen[field] === true) {
            throw new Error('"' + field + '" is not editable');
        }

        if (meta.get(proxy).loaded) {
            auth.authorize('set', permissions, field, val);
        }

        //  type will be undefined for a loading persistant object
        //  checking meta ensures persistant objects are allowed
        if (get_type(val)) {
            var time = get_time();
            var operation = 'set';
            if (meta.get(proxy).loaded && meta.get(proxy).backup) {
                records.save({
                    time      : time,
                    id        : id,
                    operation : operation,
                    field     : field,
                    value     : serializable_from_instance(val, [{name: id, type : 'reference'}])
                });
            }
            if (val !== undefined) hash[field] = val;
            else delete hash[field];

            if (field == 'permissions') {
                permissions = val;
            }

            var self_reference = [{name : id, type : 'reference'}];
            var field_reference = self_reference.concat([{
                name : field,
                type : 'reference'
            }]);

            //  send to watching this field and this proxy
            send_to_watching(null, self_reference, proxy);
            send_to_watching(null, field_reference, val);
        }
        else {
            throw new Error((typeof val) +  ' not supported in persistant object');
        }
    }

    var list = [];

    function list_set_field(target, field, val, receiver) {
        if (isNaN(parseInt(field)) && field !== 'render' && field !== 'permissions' ) {
            throw new Error('List indices must be numeric');
        }

        if (meta.get(proxy).field_settings.frozen[field] === true) {
            throw new Error('"' + field + '" is not editable');
        }

        if (meta.get(proxy).loaded) {
            auth.authorize('set', permissions, field, val);
        }

        //  type will be undefined for a loading persistant object
        //  checking meta ensures persistant objects are allowed
        if (get_type(val)) {
            var time = get_time();
            var operation = 'set';
            if (meta.get(proxy).loaded && meta.get(proxy).backup) {
                records.save({
                    time      : time,
                    id        : id,
                    operation : operation,
                    field     : field,
                    value     : serializable_from_instance(val, [{name: id, type : 'reference'}])
                });
            }
            list[field] = val;

            if (field == 'permissions') {
                permissions = val;
            }

            var self_reference = [{name : id, type : 'reference'}];
            var field_reference = self_reference.concat([{
                name : field,
                type : 'reference'
            }]);

            //  send to watching this field and this proxy
            send_to_watching(null, self_reference, proxy);
            send_to_watching(null, field_reference, val);
        }
    }

    function set_set_field() {
        throw new Error('Cannot set fields on a set.');
    }

    function list_concat() {
        var item;
        var i;
        var j;

        for (i=0; i<arguments.length; i++) {
            item = arguments[i];
            if (!util.isArray(item) && get_type(item) !== 'list') {
                throw new Error('Can only concatenate Lists and native Arrays (example: [])');
            }
        }

        for (i=0; i<arguments.length; i++) {
            item = arguments[i];
            for (j=0; j<item.length; j++) {
                if (get_type(item[j])) {
                    continue;
                }
                else {
                    throw new Error('index ' + j + ' in argument ' + i + ' is invalid\nAll items to be concatenated must be of a persistant type');
                }
            }
        }

        var concatenated = create('list');

        for (i=0; i<list.length; i++) {
            concatenated.push(list[i]);
        }

        for (i=0; i<arguments.length; i++) {
            item = arguments[i];
            for (j=0; j<item.length; j++) {
                concatenated.push(item[j]);
            }
        }

        return concatenated;
    }
    function list_indexOf(item, start) {
        return list.indexOf(item, start);
    }
    function list_lastIndexOf(item, start) {
        return list.lastIndexOf(item, start);
    }
    function list_pop() {
        var time = get_time();
        var operation = 'call';
        var field = 'pop';
        if (meta.get(proxy).loaded && meta.get(proxy).backup) {
            records.save({
                time      : time,
                id        : id,
                operation : operation,
                field     : field,
                arguments : []
            });
        }

        //  TODO: send extra update data notifying that this was a pop
        var value = list.pop();
        var self_reference = [{name : id, type : 'reference'}];
        send_to_watching(null, self_reference, {
            type : 'list',
            operation : 'pop'
        });

        send_to_watching(null, self_reference.concat([{
            name : list.length + '',
            type : 'reference'
        }]), undefined);

        return value;
    }
    function list_push() {
        var time = get_time();
        var operation = 'call';
        var field = 'push';

        var self_reference = [{name : id, type : 'reference'}];

        //  get serialized versions of all arguments
        //  this guarantees that all arguments are serializable
        //     if not, will error out
        var args = [];
        for (var i=0; i<arguments.length; i++) {
            var arg = serializable_from_instance(arguments[i]);
            args.push(arg);
        }

        list.push.apply(list, arguments);

        if (meta.get(proxy).loaded && meta.get(proxy).backup) {
            records.save({
                time      : time,
                id        : id,
                operation : operation,
                field     : field,
                arguments : args
            });
        }

        //  TODO: send extra update data notifying that this was a push
        send_to_watching(null, self_reference, {
            type : 'list',
            operation : 'push',
            arguments : args
        });

        for (var i=0; i<args.length; i++) {
            send_to_watching(null, self_reference.concat([{
                name : (list.length-1-i) + '',
                type : 'reference'
            }]), arguments[i]);
        }

        return list.length;
    }
    function list_reverse() {
        var time = get_time();
        var operation = 'call';
        var field = 'reverse';
        if (meta.get(proxy).loaded && meta.get(proxy).backup) {
            records.save({
                time      : time,
                id        : id,
                operation : operation,
                field     : field,
                arguments : []
            });
        }
        list.reverse();

        var self_reference = [{name : id, type : 'reference'}];
        send_to_watching(null, self_reference, {
            type : 'list',
            operation : 'reverse'
        });

        for (var i=0; i<list.length; i++) {
            if (list.length%2 && i == (list.length+1)/2) {
                //  if odd length list and this is middle
                //  index, it does not change on a reverse
                continue;
            }
            var ref = self_reference.concat([{
                name : i + '',
                type : 'reference'
            }]);
            //  send new value to all watching
            send_to_watching(null, ref, list[i]);
        }

        return proxy;
    }
    function list_shift() {
        var time = get_time();
        var operation = 'call';
        var field = 'shift';
        if (meta.get(proxy).loaded && meta.get(proxy).backup) {
            records.save({
                time      : time,
                id        : id,
                operation : operation,
                field     : field,
                arguments : []
            });
        }

        var value = list.shift();

        //  TODO: send extra update data notifying that this was a shift
        var self_reference = [{name : id, type : 'reference'}];
        send_to_watching(null, self_reference, {
            type : 'list',
            operation : 'shift'
        });

        //  send updates for all list indices
        //  include the +1 at the end that used to exist
        for (var i=0; i<list.length + 1; i++) {
           var ref = self_reference.concat([{
                name : i + '',
                type : 'reference'
            }]);
            //  send new value to all watching
            send_to_watching(null, ref, list[i]);
        }

        return value;
    }
    function list_slice(start, end) {
        var items = list.slice(start, end);
        //  TODO: this implementation creates 2 lists, one here
        //        and one inside the concat operation.
        //        optimize later
        return create('list').concat(items);
    }
    function list_sort(fn) {
        var time = get_time();
        var operation = 'call';
        var field = 'sort';
        var args = [];
        if (fn) {
            if (get_type(fn) !== 'function') {
                throw new Error('first argument of sort is an optional, and if provided must be a function');
            }
            args.push(serializable_from_instance(fn));
        }

        list.sort(fn);

        if (meta.get(proxy).loaded && meta.get(proxy).backup) {
            records.save({
                time      : time,
                id        : id,
                operation : operation,
                field     : field,
                arguments : args
            });
        }

        //  send update data notifying that this was a sort
        var self_reference = [{name : id, type : 'reference'}];
        send_to_watching(null, self_reference, {
            type : 'list',
            operation : 'sort'
        });

        //  TODO: can optimize by not sending updates for unchanged values
        for (var i=0; i<list.length; i++) {
           var ref = self_reference.concat([{
                name : i + '',
                type : 'reference'
            }]);
            //  send new value to all watching
            send_to_watching(null, ref, list[i]);
        }

        return proxy;
    }
    function list_splice() {

        var time = get_time();
        var operation = 'call';
        var field = 'splice';
        var args = [];

        //  ensure first two arguments are numbers
        if (get_type(arguments[0]) !== 'number') {
            throw new Error('First argument must be an integer');
        }
        if (get_type(arguments[1]) !== 'number') {
            throw new Error('Second argument must be an integer');
        }

        //  ensure all items we are splicing in are serializable
        for (var i=0; i<arguments.length; i++) {
            if (get_type(arguments[i])) {
                args.push(serializable_from_instance(arguments[i]));
            }
            else {
                throw new Error((i-2)  + ' item to insert is not serializable');
            }
        }

        if (meta.get(proxy).loaded && meta.get(proxy).backup) {
            records.save({
                time      : time,
                id        : id,
                operation : operation,
                field     : field,
                arguments : args
            });
        }

        var prev_list_length = list.length;
        var spliced = list.splice.apply(list, arguments);

        var self_reference = [{name : id, type : 'reference'}];
        send_to_watching(null, self_reference, proxy);

        //  send updates to all possible changed values
        for (var i=arguments[0]; i<Math.max(prev_list_length, list.length); i++) {
           var ref = self_reference.concat([{
                name : i + '',
                type : 'reference'
            }]);
            //  send new value to all watching
            send_to_watching(null, ref, list[i]);
        }

        return create('list').concat(spliced);
    }
    function list_unshift() {
        var time = get_time();
        var operation = 'call';
        var field = 'unshift';

        //  get serialized versions of all arguments
        //  this guarantees that all arguments are serializable
        //     if not, will error out
        var args = [];
        for (var i=0; i<arguments.length; i++) {
            args.push(serializable_from_instance(arguments[i]));
        }

        list.unshift.apply(list, arguments);

        if (meta.get(proxy).loaded && meta.get(proxy).backup) {
            records.save({
                time      : time,
                id        : id,
                operation : operation,
                field     : field,
                arguments : args
            });
        }

        var self_reference = [{name : id, type : 'reference'}];
        send_to_watching(null, self_reference, {
            type : 'list',
            operation : 'unshift',
            arguments : args
        });

        //  send updates to all possible changed values
        for (var i=0; i<list.length; i++) {
           var ref = self_reference.concat([{
                name : i + '',
                type : 'reference'
            }]);
            //  send new value to all watching
            send_to_watching(null, ref, list[i]);
        }

        return list.length;
    }

    return proxy;
}
