//  process must be started with --harmony flag
var fs = require('fs');
var vm = require('vm');
var Promise = require('promise');
var files = require('files');
var references = require('./references.js');
var net = require('net');

module.exports.handleWS      = handleWS;
module.exports.handleTCP     = handleTCP;
module.exports.identify      = identify;
module.exports.create        = create;
module.exports.unload        = unload;
module.exports.load          = load;
module.exports.is            = is;
module.exports.on            = on;
module.exports.exists        = exists;
module.exports.resolve_hosts = resolve_hosts;

var events = {}

function exists(id, callback) {
    fs.exists('/persist/' + id, function (exists) {
        if (exists) callback(null, true);
        else        callback(null, false);
    });
}

function on(event, listener) {
    if (events[event] === undefined) events[event] = [];
    events[event].push(listener);
}

function trigger(event, data) {
    if (events[event]) {
        for (var i=0; i<events[event].length; i++) {
            events[event][i](data);
        }
    }
}

var root_reference = 'placeholder root';

function error_report(error, serialize, reference) {
    var report = {
        type : 'error',
        reference : reference,
        data : error.toString()
    };
    if (serialize) report = JSON.stringify(report);
    return report;
}

//  handle request over JSON protocol
function JSONprotocol(context, respond, external_requester) {
    // call given respond function in context with response
    function send(response) {respond.call(context, response);}
    return function (data) {
        try {
            var operation = JSON.parse(data + '');
            if (external_requester) {
                //  a reference lookup from an external
                //  requester must initialize a requester list
                //  so we can start with a trusted list
                operation.requesters = [external_requester];
            }
            resolve_and_execute(operation, function (error, value) {
                if (error) send(error_report(error, true, operation));
                else       send(JSON.stringify(value));
            });
        }
        catch (error) {
            send(error_report(error, true, data));
        }
    }
}

function handleWS(connection) {
    //  TODO: set proper requester
    var respond = JSONprotocol(connection, connection.send, 'external requester');
    connection.on('message', respond);
    connection.on('close', function () {});
}

function handleTCP(connection) {
    var respond = JSONprotocol(connection, connection.write);
    connection.on('data', respond);
    connection.on('end', function () {});
}

function expectation_met(expectation, value) {
    var type = get_type(value);
    var met = false;
    if (type == 'string') {
        met = value === expectation.data;
    }
    else if (type == 'function') {
        met = value.toString() == expectation.data;
    }
    else if (type == 'boolean') {
        met = value == expectation.data;
    }
    else if (type == 'null') {
        met = expectation.type == 'null';
    }
    else if (type == 'number') {
       met = expectation.data == value;
    }
    else if (type == 'reference') {
        met = false; //  TODO: compare reference strategy
    }
    else if (type == 'file') {
        met = false; //  TODO: compare file strategy
    }
    else {
        met = value === undefined && expectation.type == 'undefined';
    }
    return met;
}

function unserialize(value) {
    var unserialized;
    //  TODO: if value.data has unexpected form
    //        for type, throw an error
    if (value.type == 'string') {
        unserialized = value.data;
    }
    else if (value.type == 'function') {
        unserialized = scoped(value.data, {});
    }
    else if (value.type == 'boolean') {
        unserialized = value.data;
    }
    else if (value.type == 'null') {
        unserialized = null;
    }
    else if (value.type == 'number') {
        unserialized = value.data;
    }
    else if (value.type == 'reference') {
        unserialized = new Reference(value.data);
    }
    else if (value.type == 'file') {
        unserialized = new File(value.data);
    }
    else {
        throw new Error('cannot unserialize type: ' + value.type);
    }
    return unserialized;
}

function resolve_and_execute(operation, callback) {
    // TODO: add followed path portion to reference so we
    //       can check circular references between processes
    // TODO: check authorization of requesters in reference
    var reference = operation.reference;
    var value = proxies[reference.id];
    if (value) {
        var value_parent = null;
        if (reference.internal) {
            var internal = reference.internal.split('.');
            value_parent = reference.id;
            while (internal.length) {
                var type = get_type(value);
                if (type == 'hashmap' || type == 'list') {
                    value_parent = meta.get(value).id;
                    value = value[internal.shift()];
                    if (value === undefined && internal.length) {
                        callback(null, {
                            type : 'error',
                            reference : reference, 
                            data : 'invalid reference'
                        });
                        return;
                    }
                }
                else if (type == 'reference') {
                    var op = {
                        type : operation.type,
                        reference : {
                            id       : value.id,
                            internal : internal.join('.')
                        },
                        requesters : reference.requesters.concat([root_name]),
                        path       : reference.path.concat([])
                    };
                    if (proxies[value.id]) {
                        //  this is hosting the given reference
                        resolve_and_execute(op, callback);
                        return;
                    }
                    else if (host_resolver) {
                        host_resolver(op.reference.id, function (err, hostname) {
                            if (err) callback('error occurred resolving host for reference');
                            else {
                                //  make TCP request to proper host
                                var client = net.connect({
                                    host : hostname
                                }, function () {
                                    client.write(JSON.stringify(op));
                                });
                                client.on('data', function (data) {
                                    callback(null, JSON.parse(data));
                                    client.end();
                                });
                            }
                        });
                        return;
                    }
                    else {
                        callback(null, {
                            type      : 'error',
                            reference : reference,
                            data : 'no external hosts to look for and not loaded into this host.'
                        });
                        return;
                    }
                }
            }
        }
        //  perform proper operation
        if (operation.type == 'source reference') {
            serializable(value, reference, callback);
        }
        else if (operation.type == 'reference') {
            //  TODO if value is function, execute and return
            //       if value is reference, return referenced object
        }
        else if (operation.type == 'set') {
            if (expectation_met(operation.expected, value)) { //  TODO: check expectation
                var parent_reference = operation.reference.internal.split('.').pop();
                proxies[value_parent][parent_reference] = unserialize(operation.value);
                callback(null, {type : 'success', reference : reference});
            }
            else callback(null, {type : 'error', reference : reference, data : 'expected value before set did not match'});
        }
        else callback('invalid operation type: ' + operation.type);
    }
    else {
        host_resolver(reference.id, function (err, data) {
            if (err) callback('error occurred resolving host for reference');
            else if (data) {
                //  make TCP request to proper host
                var client = net.connect(data.port, data.host, function () {
                    client.write(JSON.stringify(operation));
                });
                client.on('data', function (data) {
                    callback(null, JSON.parse(data));
                    client.end();
                });
            }
            else callback('could not resolve host for reference');
        });
    }
}

function serializable(value, reference, callback) {
        var type = get_type(value);
        var serializable = {};
        serializable.type = type;
        serializable.reference = reference;
        if (type == 'hashmap') {
            serializable.data = {};
            var id = meta.get(value).id;
            for (var field in value) {
                serializable.data[field] = {
                    id       : id,
                    internal : field
                };
            }
        }
        else if (type == 'string' || type == 'boolean' || type == 'null' || type == 'number') {
            serializable.data = value;
        }
        else if (type == 'reference') {
            serializable.data = 'reference...';
        }
        else if (type == 'file') {
            serializable.data = 'file...';
        }
        else if (type == 'function') {
            serializable.data = value.toString();
        }
        else {
            throw new Error(value + ' is not serializable');
        }
        callback(null, serializable);
}

var File = files.file;
var Reference = references.reference;

var host_resolver = null;

var meta = new Map();
var proxies = {};

var begin      = (new Date()).getTime() * 1e6;
var first_time = process.hrtime();

function getTime() {
    var elapsed = process.hrtime(first_time);
    return begin + elapsed[0] * 1e9 + elapsed[1];
}

var PROCESS_ID = getTime() + Math.random() + '';
var PERSIST_RECORD_DELAY = 100;

function isNumber(value) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}

function save_record(record) {
    var id = record.id;
    var pending = meta.get(proxies[id]).pending_records;
    pending.push(record);
}

function persist_records(proxy) {
    function next() {
        setTimeout(function () {
            persist_records(proxy);
        }, PERSIST_RECORD_DELAY);
    }

    var state = meta.get(proxy);
    var pending = state.pending_records;

    if (pending.length) {
        var data = '';
        while (pending.length) {
            var s = JSON.stringify(pending.shift());
            data += '\n' + s;
        }
        fs.appendFile('/persist/' + state.id, data, function (err) {
            if (err) console.log(err);
            next();
        });
    }
    else if (state.unloading) state.onunload();
    else                      next();
}

function lock(id, callback) {
    //  lock policy handled outside of this module
    callback(null);
}

function unlock(persistant, callback) {
    //  lock and unlock policy handled outside of this module
    callback(null)
}

function get_type(val) {
    if      (typeof val == 'string'  ) return 'string';
    else if (typeof val == 'number'  ) return 'number';
    else if (typeof val == 'boolean' ) return 'boolean';
    else if (typeof val == 'function') return 'function';
    else if (typeof val == 'date'    ) return 'date';
    else if (val === null            ) return 'null';
    else if (meta.has(val)           ) return meta.get(val).type;
    else if (val instanceof File     ) return 'file';
    else if (references.is(val)      ) return 'reference';
    else return undefined;
}

function get_persistant_proxy(id, context) {
    var hash = {};

    function set_field(target, field, val, receiver) {
        var type = meta.get(proxy).type;

        var LIST = type == 'list';
        var HASH = type == 'hashmap';

        if (LIST && !isNumber(field)) {
            throw new Error('arrays are only indexed with numeric values');
        }

        var type = get_type(val);
        var persistant = meta.has(val)

        //  type will be undefined for a loading persistant object
        //  checking meta ensures persistant objects are allowed
        if (persistant || type) {
            var time = getTime();
            var operation = 'set';
            var value = val + '';

            if (persistant) {
                value = meta.get(val).id;
                meta.get(proxy).dependencies.push(val);
            }
            else if (type == 'function') {
                val = scoped(value, context);
            }
            else if (type == 'file')      value = value.url;
            else if (type == 'reference') value = value.path;

            if (meta.get(proxy).loaded) {
                save_record({
                    time      : time,
                    id        : id,
                    operation : operation,
                    field     : field,
                    type      : type,
                    value     : value
                });
            }
            if      (LIST) list[field] = val;
            else if (HASH) hash[field] = val;
        }
        else {
            throw new Error((typeof val) + ' not supported in persistant object');
        }
    }

    var proxy = Proxy.create({
        getOwnPropertyDescriptor : function (target, name) {
            return hash[name];
        },
        getOwnPropertyNames : function (target) {
            var properties = [];
            for (var property in hash) {
                if (hash.hasOwnProperty(property)) {
                    properties.push(property);
                }
            }
            return properties;
        },
        delete : function (name) {
            delete hash[name];
        },
        freeze : function () {},
        seal : function () {},
        preventExtensions : function () {},
        has : function () {},
        hasOwn : function () {},
        get : function (target, name, receiver) {
            return hash[name];
        },
        set : set_field,
        enumerate : function (target) {
            var properties = [];
            for (var property in hash) {
                if (hash.hasOwnProperty(property)) {
                    properties.push(property);
                }
            }
            return properties;
        },
        keys : function (target) {
            var properties = [];
            for (var property in hash) {
                if (hash.hasOwnProperty(property)) {
                    properties.push(property);
                }
            }
            return properties;
        },
        apply : function () {},
        construct : function () {}
    });

    meta.set(proxy, {
        id              : id,
        hash            : hash,
        loaded          : false,
        unloading       : false,
        pending_records : [],
        dependencies    : [],
        onload          : [],
    });

    proxies[id] = proxy;

    persist_records(proxy);

    trigger('control', id);

    return proxy;
}

function scoped(expression, context) {
    vm.runInNewContext('var _tmp_ = ' + expression, context);
    var value = context._tmp_;
    delete context._tmp;
    return value;
}

var valid_types = {
    'hashmap' : true,
    'list' : true
};

function create(type, context, id) {
    if (context === undefined) context = {};
    else if (typeof context !== 'object') {
        throw new Error('context must be object');
    }
    if (valid_types[type] === undefined) {
        throw new Error('"' + type + '" is not a valid type');
    }

    //  creates persistant object of type with a new id
    if (id === undefined) id = getTime() + '';

    var proxy = get_persistant_proxy(id, context);
    save_record({
        time      : getTime(),
        id        : id,
        operation : 'create',
        field     : 'type',
        type      : type,
        value     : type
    });
    lock(id, function (err, res) {
        if (err) console.log(err);
    });
    meta.get(proxy).loaded = true;
    meta.get(proxy).type = type;
    return proxy;
}

function identify(persistant) {
    if (meta.has(persistant)) {
        return meta.get(persistant).id;
    }
    else {
        throw new Error('cannot identify non-persistant item');
    }
}

function load(id, context, callback) {
    var proxy = proxies[id];
    if (proxy) {
        if (meta.get(proxy).loaded) {
            if (callback) callback(null, proxies[id]);
        }
        else if (callback) {
            meta.get(proxy).onload.push(callback);
        }
        return proxy;
    }

    if (context === undefined) context = {};
    else if (typeof context !== 'object') {
        throw new Error('context must be object not ' + (typeof context));
    }
    if (typeof id != 'string') throw new Error('get requires id');

    var proxy = get_persistant_proxy(id, context);

    if (callback) meta.get(proxy).onload.push(callback);

    function load_records() {
        //  load this proxy's history to get current state
        fs.readFile('/persist/' + id, function (err, res) {
            if (err) {
                callback(err);
                return;
            }
            function handle_record(record) {
                var type = record.type;
                if (record.operation == 'create') {
                    meta.get(proxy).type = type;
                    return;
                }
                var value = record.value;

                if      (type == 'boolean'  ) value = value === 'true';
                else if (type == 'null'     ) value = null;
                else if (type == 'number'   ) value = parseFloat(value);
                else if (type == 'function' ) value = scoped(value, context);
                else if (type == 'file'     ) value = new File(value);
                else if (type == 'reference') value = new Reference(value);
                else if (type == 'hashmap' || type == 'list') {
                    value = load(value, context, check_done);
                }
                proxy[record.field] = value;
            }
            var data = res.toString();
            var records = data.split('\n');
            records.shift(); // first == ''
            while (records.length) {
                handle_record(JSON.parse(records.shift()));
            }
            meta.get(proxy).loaded = true;
            var done = false;
            function check_done() {
                if (done) return;
                var dependencies = meta.get(proxy).dependencies;
                for (var i = 0; i < dependencies.length; i++) {
                    if(!meta.get(dependencies[i]).loaded) return;
                }
                done = true;
                var onload = meta.get(proxy).onload;
                for (var i = 0; i < onload.length; i++) {
                    onload[i](null, proxy);
                }
            }
            check_done();
        });
    }

    lock(id, function (err, res) {
        if (err) console.log(err);
        else     load_records();
    });
    return proxy;
}

function is(proxy) {
    return meta.has(proxy);
}

function unload(proxy, callback) {
    if (!meta.has(proxy)) {
        throw new Error('cannot unload non persistant item');
    }
    else if (meta.get(proxy).unloading) {
        throw new Error('already unloading');
    }

    var id   = meta.get(proxy).id;
    var deps = meta.get(proxy).dependencies;
 
    meta.get(proxy).unloading = true;

    var todo = 1;
    function done(err) {
        if (err) console.log(err);
        else     todo -= 1;
        
        if (todo == 0 && callback) callback(null);
    }

    for (var i=0; i<deps.length; i++) {
        if (meta.has(deps[i]) && !meta.get(deps[i]).unloading) {
            todo += 1;
            unload(deps[i], done);
        }
    }

    meta.get(proxy).onunload = function () {
        meta.delete(proxy);
        delete proxies[id];
        unlock(id, done);
    }
}

function resolve_hosts(resolver) {
    //  resolver is a function that takes an id and
    //  calls back with error or a host that owns the
    //  given id
    host_resolver = resolver;
}

//  TODO: serve historical version of object
