//  process must be started with --harmony flag
var net = require('net');

var File = require('./file');
var Reference = require('./reference');
var error_report = require('./error_report');
var get_time = require('./get_time');
var get_type = require('./get_type');
var serializable_from_instance = require('./serializable_from_instance');
var instance_from_serializable = require('./instance_from_serializable');
var scoped = require('./scoped');
var get_persistant_proxy = require('./get_persistant_proxy');
var meta = require('./meta');
var send_to_watching = require('./send_to_watching');
var proxies = require('./proxies');
var events = require('./events');
var hash_reference = require('./hash_reference');
var unload = require('./unload');
var load = require('./load');
var create = require('./create');
var exists = require('./exists')
var watched_references = require('./watched_references');

module.exports.handleWS      = handleWS;
module.exports.handleTCP     = handleTCP;
module.exports.identify      = identify;
module.exports.create        = create;
module.exports.unload        = unload;
module.exports.load          = load;
module.exports.is            = is;
module.exports.on            = events.on;
module.exports.exists        = exists;
module.exports.resolve_hosts = resolve_hosts;

var host_resolver = null;

//  handle request over JSON protocol
function JSONprotocol(context, respond, external_requester) {
    //  TODO: gaurd against circular reference
    context.respond = respond;
    function send(response) {respond.call(context, '"""' + response);}
    return function (data) {
        //  sometimes multiple writes are lumped into data
        //  """ cannot occur in JSON so we append it to all
        //  JSON requests
        var operations = (data + '').split('"""');
        while (operations.length) {
            var operation = operations.shift();
            if (operation != '') {
                process_operation(context, operation, send, external_requester);
            }
        }
    }
}

function process_operation(context, operation, send, external_requester) {
    try {
        operation = JSON.parse(operation);
        if (operation.token === undefined) {
            operation.token = get_time() + '';
        }
        if (external_requester) {
            //  a reference lookup from an external
            //  requester must initialize a requester list
            //  so we can start with a trusted list
            operation.requesters = [external_requester];
        }
        //  if response waiting for token, execute response callback
        //  TODO: make this robust against requests that
        //        legitimately need to return to previous
        //        servers to resolve. ex: reference chain
        if (responses[operation.token]) {
            responses[operation.token](null, operation);
            delete responses[operation.token];
        }
        else {
            resolve_and_execute(context, operation, function (error, value) {
                if (error) {
                    var error_rep = error_report(error, false, operation.reference);
                    error_rep.token = operation.token;
                    send(JSON.stringify(error_rep));
                }
                else {
                    value.token = operation.token;
                    send(JSON.stringify(value));
                }
            });
        }
    }
    catch (error) {
        console.log(operation);
        throw error;
        send(error_report(error, true, JSON.data + ''));
    }
}

function handleWS(connection) {
    //  TODO: set proper requester
    var requester = 'external websocket (client) requester';
    var respond = JSONprotocol(connection, connection.send, requester);
    connection.on('message', respond);
    connection.on('close', close_connection(connection));
    connection.open = true;
}

function handleTCP(connection) {
    //  TODO: set proper requester (will be another persist instance)
    var requester = 'external tcp (persist) requester';
    var respond = JSONprotocol(connection, connection.write, requester);
    connection.on('data', respond);
    connection.on('end', close_connection(connection));
    connection.open = true;
}

function close_connection(connection) {
    return function () {
        //  TODO: clean up watching infrastructure
        connection.open = false;
    }
}

function resolve_and_execute(context, operation, callback) {
    // TODO: add followed path portion to reference so we
    //       can check circular references between processes
    // TODO: check authorization of requesters in reference
    var reference = operation.reference;
    var value = proxies[reference.id];
    if (operation.type == 'update') {
        //  updates come from instances this instance is watching,
        //  so we pass updates to instances that watch this one
        value = instance_from_serializable(operation.value);
        update_operation(context, reference, value, callback);
    }
    else if (value) {
        var value_parent = null;
        if (reference.internal) {
            var internal = reference.internal.split('.');
            value_parent = reference.id;
            while (internal.length) {
                var type = get_type(value);
                if (type == 'hashmap' || type == 'list') {
                    value_parent = meta.get(value).id;
                    value = value[internal.shift()];
                    if (value === undefined && internal.length) {
                        callback('invalid reference');
                        return;
                    }
                }
                else if (type == 'reference') {
                    resolve_and_execute(context, {
                        type : operation.type,
                        reference : {
                            id       : value.id,
                            internal : internal.join('.')
                        },
                        token : operation.token,
                        requesters : reference.requesters.concat([root_name]),
                        path       : reference.path.concat([])
                    }, callback);
                    return;
                }
            }
        }
        //  perform proper operation
        if (operation.type == 'source reference') {
            reference_operation(value, operation, reference, callback);
        }
        else if (operation.type == 'evaluate') {
            evaluate_operation(value, operation, reference, callback);
        }
        //  watch operations must be passed to the proper server 
        else if (operation.type == 'watch') {
            watch_operation(context, value, operation, reference, callback);
        }
        else callback('invalid operation type: ' + operation.type);
    }
    else resolve_and_execute_external(context, operation, callback);
}

function reference_operation(value, operation, reference, callback) {
    var ref_str = reference.id;
    if (value == undefined) callback('invalid reference');
    else serializable_from_instance(value, reference, function (err, res) {
        if (err) callback(err);
        else {
            res.token = operation.token;
            callback(null, res);
        }
    });
}

function evaluate_operation(value, operation, reference, callback) {
    //  if value is function, execute and return
    var type = get_type(value);
    if (type == 'hashmap') {
        var returned;
        try {
            var fn = scoped("function () {" + operation.script + "}");
            returned = fn.apply(value);
            var res = {
                type : "success",
                token : operation.token,
                reference : reference,
                value : serializable_from_instance(returned)
            };
            callback(null, res);
        }
        catch (error) {
            callback(error + "");
        }
    }
    else callback('scripts must be evaluated in the context of a persistant object');
}

function watch_operation(context, value, operation, reference, callback) {
    var hashed_reference = hash_reference(reference);
    var watching = watched_references[hashed_reference];
    if (watching == undefined) {
        watching = [];
        watched_references[hashed_reference] = watching;
    }
    var already_watching = false;

    for (var i=0; i<watching.length; i++) {
        if (watching[i] == context) {
            already_watching = true;
            break;
        }
    }

    if (!already_watching) watching.push(context);

    callback(null, {
        type : 'success',
        token : operation.token,
        reference : reference
    });
}

function update_operation(context, reference, value, callback) {
    send_to_watching(context, reference, value);
    //  TODO: what to do with callback?
}

var connections = {};
var responses = {};

function resolve_and_execute_external(context, operation, callback) {
    host_resolver(operation.reference.id, function (err, data) {
        if (err) callback('error occurred resolving host for reference');
        else if (data) {
            //  make TCP request to proper host
            var host_reference = data.host + ':' + data.port;
            if (connections[host_reference] == undefined) {
                var client = net.connect(data.port, data.host, function () {
                    client.write('"""' + JSON.stringify(operation));
                });
                var external_requester = 'value for external requester';
                client.on('data', JSONprotocol(client, client.write, external_requester));
                client.on('end', function () {
                    //  TODO: clean up connections
                });
                connections[host_reference] = client;
            }
            else {
                connections[host_reference].write('"""' + JSON.stringify(operation));
            }
            if (operation.type == 'watch') {
                var hashed_reference = hash_reference(operation.reference);
                var watching = watched_references[hashed_reference];
                if (watching == undefined) {
                    watching = [];
                    watched_references[hashed_reference] = watching;
                }
                var already_watching = false;

                for (var i=0; i<watching.length; i++) {
                    if (watching[i] == context) {
                        already_watching = true;
                        break;
                    }
                }

                if (!already_watching) watching.push(context);
                
                callback(null, {
                    type : 'success',
                    token : operation.token,
                    reference : operation.reference
                });
            }
            else responses[operation.token] = callback;
        }
        else callback('could not resolve host for reference');
    });
}

function identify(persistant) {
    if (meta.has(persistant)) {
        var id = meta.get(persistant).id
        return id;
    }
    else {
        throw new Error('cannot identify non-persistant item');
    }
}

function is(proxy) {
    return meta.has(proxy);
}

function resolve_hosts(resolver) {
    //  resolver is a function that takes an id and
    //  calls back with error or a host that owns the
    //  given id
    host_resolver = resolver;
}

//  TODO: serve historical version of object
