//  process must be started with --harmony flag
var fs = require('fs');
var vm = require('vm');
var Promise = require('promise');
var files = require('files');
var references = require('./references.js');

module.exports.handleWS      = handleWS;
module.exports.handleTCP     = handleTCP;
module.exports.identify      = identify;
module.exports.create        = create;
module.exports.unload        = unload;
module.exports.load          = load;
module.exports.is            = is;
module.exports.resolve_hosts = resolve_hosts;

function error_report(error, serialize, reference) {
    var report = {
        type : 'error',
        reference : reference,
        data : error.toString()
    };
    if (serialize) report = JSON.stringify(report);
    return report;
}

//  handle request over JSON protocol
function JSONprotocol(context, respond) {
    // call given respond function in context with response
    function send(response) {respond.call(context, response);}
    return function (data) {
        //  TODO: handle set operations
        //  TODO: handle function call
        try {
            var info = JSON.parse(data);
            serializable(info, function (error, response) {
                if (error) send(error_report(error, true, info));
                else       send(JSON.stringify(response));
            });
        }
        catch (error) {
            send(error_report(error, true, info));
        }
    }
}

function handleWS(connection) {
    var respond = JSONprotocol(connection, connection.send);
    connection.on('message', respond);
    connection.on('close', function () {});
}

function handleTCP(connection) {
    var respond = JSONprotocol(connection, connection.write);
    connection.on('data', respond);
    connection.on('end', function () {});
}


function serializable(reference, callback) {
    // TODO: add followed path portion to reference so we
    //       can check circular references between processes
    var value = proxies[reference.id];
    if (value) {
        if (reference.internal) {
            var internal = reference.internal.split('.');
            while (internal.length) {
                var type = get_type(value);
                var valid_types = {
                    hashmap : true,
                    list : true
                };
                if (valid_types[type]) {
                    value = value[internal.shift()];
                    if (value === undefined) {
                        callback(null, {
                            type : 'error',
                            reference : reference, 
                            data : 'invalid reference'
                        });
                        return;
                    }
                }
                else if (type == 'reference') {
                    var ref = {
                        id       : value.id,
                        internal : internal.join('.')
                    };
                    if (proxies[value.id]) {
                        //  this is hosting the given reference
                        serializable(ref, callback);
                    }
                    else if (host_resolver) {
                        host_resolver(ref.id, function (err, hostname) {
                            if (err) callback('could not resolve host for reference');
                            else {
                                //  make TCP request to proper host
                                var client = net.connect({
                                    host : hostname
                                }, function () {
                                    client.write(JSON.stringify(ref));
                                });
                                client.on('data', function (data) {
                                    callback(null, JSON.parse(data));
                                    client.end();
                                });
                            }
                        });
                        return;
                    }
                    else {
                        callback(null, {
                            type      : 'error',
                            reference : reference,
                            data : 'no external hosts to look for and not loaded into this host.'
                        });
                        return;
                    }
                }
            }
        }
        var type = get_type(value);
        var returnable = {};
        returnable.type = type;
        returnable.reference = reference;
        if (type == 'hashmap') {
            returnable.data = {};
            var id = meta.get(value).id;
            for (var field in value) {
                returnable.data[field] = {
                    id       : id,
                    internal : field
                };
            }
        }
        else if (type == 'string' || type == 'boolean' || type == 'null' || type == 'number') {
            returnable.data = value;
        }
        else if (type == 'reference') {
            returnable.data = 'reference...';
        }
        else if (type == 'file') {
            returnable.data = 'file...';
        }
        else if (type == 'function') {
            returnable.data = value.toString();
        }
        else {
            throw new Error(value + ' is not serializable');
        }
        callback(null, returnable);
    }
    else {
        callback('request sent to host without object');
    }
}

var File = files.file;
var Reference = references.reference;

var host_resolver = null;

var meta = new Map();
var proxies = {};

var begin      = (new Date()).getTime() * 1e6;
var first_time = process.hrtime();

function getTime() {
    var elapsed = process.hrtime(first_time);
    return begin + elapsed[0] * 1e9 + elapsed[1];
}

var PROCESS_ID = getTime() + Math.random() + '';
var PERSIST_RECORD_DELAY = 100;

function isNumber(value) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}

function save_record(record) {
    var id = record.id;
    var pending = meta.get(proxies[id]).pending_records;
    pending.push(record);
}

function persist_records(proxy) {
    function next() {
        setTimeout(function () {
            persist_records(proxy);
        }, PERSIST_RECORD_DELAY);
    }

    var state = meta.get(proxy);
    var pending = state.pending_records;

    if (pending.length) {
        var data = '';
        while (pending.length) {
            var s = JSON.stringify(pending.shift());
            data += '\n' + s;
        }
        fs.appendFile('/persist/' + state.id, data, function (err) {
            if (err) console.log(err);
            next();
        });
    }
    else if (state.unloading) state.onunload();
    else                      next();
}

function lock(id, callback) {
    //  lock policy handled outside of this module
    callback(null);
}

function unlock(persistant, callback) {
    //  lock and unlock policy handled outside of this module
    callback(null)
}

function get_type(val) {
    if      (typeof val == 'string'  ) return 'string';
    else if (typeof val == 'number'  ) return 'number';
    else if (typeof val == 'boolean' ) return 'boolean';
    else if (typeof val == 'function') return 'function';
    else if (typeof val == 'date'    ) return 'date';
    else if (val === null            ) return 'null';
    else if (meta.has(val)           ) return meta.get(val).type;
    else if (val instanceof File     ) return 'file';
    else if (references.is(val)      ) return 'reference';
    else return undefined;
}

function get_persistant_proxy(id, context) {
    var hash = {};

    function set_field(target, field, val, receiver) {
        var type = meta.get(proxy).type;

        var LIST = type == 'list';
        var HASH = type == 'hashmap';

        if (LIST && !isNumber(field)) {
            throw new Error('arrays are only indexed with numeric values');
        }

        var type = get_type(val);
        var persistant = meta.has(val)

        //  type will be undefined for a loading persistant object
        //  checking meta ensures persistant objects are allowed
        if (persistant || type) {
            var time = getTime();
            var operation = 'set';
            var value = val + '';

            if (persistant) {
                value = meta.get(val).id;
                meta.get(proxy).dependencies.push(val);
            }
            else if (type == 'function') {
                val = scoped(value, context);
            }
            else if (type == 'file')      value = value.url;
            else if (type == 'reference') value = value.path;

            if (meta.get(proxy).loaded) {
                save_record({
                    time      : time,
                    id        : id,
                    operation : operation,
                    field     : field,
                    type      : type,
                    value     : value
                });
            }
            if      (LIST) list[field] = val;
            else if (HASH) hash[field] = val;
        }
        else {
            throw new Error((typeof val) + ' not supported in persistant object');
        }
    }

    var proxy = Proxy.create({
        getOwnPropertyDescriptor : function (target, name) {
            return hash[name];
        },
        getOwnPropertyNames : function (target) {
            var properties = [];
            for (var property in hash) {
                if (hash.hasOwnProperty(property)) {
                    properties.push(property);
                }
            }
            return properties;
        },
        delete : function (name) {
            delete hash[name];
        },
        freeze : function () {},
        seal : function () {},
        preventExtensions : function () {},
        has : function () {},
        hasOwn : function () {},
        get : function (target, name, receiver) {
            return hash[name];
        },
        set : set_field,
        enumerate : function (target) {
            var properties = [];
            for (var property in hash) {
                if (hash.hasOwnProperty(property)) {
                    properties.push(property);
                }
            }
            return properties;
        },
        keys : function (target) {
            var properties = [];
            for (var property in hash) {
                if (hash.hasOwnProperty(property)) {
                    properties.push(property);
                }
            }
            return properties;
        },
        apply : function () {},
        construct : function () {}
    });

    meta.set(proxy, {
        id              : id,
        hash            : hash,
        loaded          : false,
        unloading       : false,
        pending_records : [],
        dependencies    : [],
        onload          : [],
    });

    proxies[id] = proxy;

    persist_records(proxy);

    return proxy;
}

function scoped(expression, context) {
    vm.runInNewContext('var _tmp_ = ' + expression, context);
    var value = context._tmp_;
    delete context._tmp;
    return value;
}

var valid_types = {
    'hashmap' : true,
    'list' : true
};

function create(type, context) {
    if (context === undefined) context = {};
    else if (typeof context !== 'object') {
        throw new Error('context must be object');
    }
    if (valid_types[type] === undefined) {
        throw new Error('"' + type + '" is not a valid type');
    }

    //  creates persistant object of type with a new id
    var id = getTime() + '';

    var proxy = get_persistant_proxy(id, context);
    save_record({
        time      : getTime(),
        id        : id,
        operation : 'create',
        field     : 'type',
        type      : type,
        value     : type
    });
    lock(id, function (err, res) {
        if (err) console.log(err);
    });
    meta.get(proxy).loaded = true;
    meta.get(proxy).type = type;
    return proxy;
}

function identify(persistant) {
    if (meta.has(persistant)) {
        return meta.get(persistant).id;
    }
    else {
        throw new Error('cannot identify non-persistant item');
    }
}

function load(id, context, callback) {
    var proxy = proxies[id];
    if (proxy) {
        if (meta.get(proxy).loaded) {
            if (callback) callback(null, proxies[id]);
        }
        else if (callback) {
            meta.get(proxy).onload.push(callback);
        }
        return proxy;
    }

    if (context === undefined) context = {};
    else if (typeof context !== 'object') {
        throw new Error('context must be object not ' + (typeof context));
    }
    if (typeof id != 'string') throw new Error('get requires id');

    var proxy = get_persistant_proxy(id, context);

    if (callback) meta.get(proxy).onload.push(callback);

    function load_records() {
        //  load this proxy's history to get current state
        fs.readFile('/persist/' + id, function (err, res) {
            if (err) {
                callback(err);
                return;
            }
            function handle_record(record) {
                var type = record.type;
                if (record.operation == 'create') {
                    meta.get(proxy).type = type;
                    return;
                }
                var value = record.value;

                if      (type == 'boolean'  ) value = value === 'true';
                else if (type == 'null'     ) value = null;
                else if (type == 'number'   ) value = parseFloat(value);
                else if (type == 'function' ) value = scoped(value, context);
                else if (type == 'file'     ) value = new File(value);
                else if (type == 'reference') value = new Reference(value);
                else if (type == 'hashmap' || type == 'list') {
                    value = load(value, context, check_done);
                }
                proxy[record.field] = value;
            }
            var data = res.toString();
            var records = data.split('\n');
            records.shift(); // first == ''
            while (records.length) {
                handle_record(JSON.parse(records.shift()));
            }
            meta.get(proxy).loaded = true;
            var done = false;
            function check_done() {
                if (done) return;
                var dependencies = meta.get(proxy).dependencies;
                for (var i = 0; i < dependencies.length; i++) {
                    if(!meta.get(dependencies[i]).loaded) return;
                }
                done = true;
                var onload = meta.get(proxy).onload;
                for (var i = 0; i < onload.length; i++) {
                    onload[i](null, proxy);
                }
            }
            check_done();
        });
    }

    lock(id, function (err, res) {
        if (err) console.log(err);
        else     load_records();
    });
    return proxy;
}

function is(proxy) {
    return meta.has(proxy);
}

function unload(proxy, callback) {
    if (!meta.has(proxy)) {
        throw new Error('cannot unload non persistant item');
    }
    else if (meta.get(proxy).unloading) {
        throw new Error('already unloading');
    }

    var id   = meta.get(proxy).id;
    var deps = meta.get(proxy).dependencies;
 
    meta.get(proxy).unloading = true;

    var todo = 1;
    function done(err) {
        if (err) console.log(err);
        else     todo -= 1;
        
        if (todo == 0 && callback) callback(null);
    }

    for (var i=0; i<deps.length; i++) {
        if (meta.has(deps[i]) && !meta.get(deps[i]).unloading) {
            todo += 1;
            unload(deps[i], done);
        }
    }

    meta.get(proxy).onunload = function () {
        meta.delete(proxy);
        delete proxies[id];
        unlock(id, done);
    }
}

function resolve_hosts(resolver) {
    //  resolver is a function that takes an id and
    //  calls back with error or a host that owns the
    //  given id
    host_resolver = resolver;
}

//  TODO: serve historical version of object
