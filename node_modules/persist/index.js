//  process must be started with --harmony flag
var fs = require('fs');
var net = require('net');
var vm = require('vm');
var Promise = require('promise');
var files = require('files');
var references = require('./references.js');
var toolbox = require('toolbox');

module.exports.handleWS      = handleWS;
module.exports.handleTCP     = handleTCP;
module.exports.identify      = identify;
module.exports.create        = create;
module.exports.unload        = unload;
module.exports.load          = load;
module.exports.is            = is;
module.exports.on            = on;
module.exports.exists        = exists;
module.exports.resolve_hosts = resolve_hosts;

var File = files.file;
var Reference = references.reference;

var host_resolver = null;

var meta    = new Map();
var proxies = {};
var events  = {};

var begin      = (new Date()).getTime() * 1e6;
var first_time = process.hrtime();

function getTime() {
    var elapsed = process.hrtime(first_time);
    return begin + elapsed[0] * 1e9 + elapsed[1];
}

var PERSIST_RECORD_DELAY = 1000;

function exists(id, callback) {
    fs.exists('/persist/' + id, function (exists) {
        if (exists) callback(null, true);
        else        callback(null, false);
    });
}

function on(event, listener) {
    if (events[event] === undefined) events[event] = [];
    events[event].push(listener);
}

function trigger(event, data) {
    if (events[event]) {
        for (var i=0; i<events[event].length; i++) {
            events[event][i](data);
        }
    }
}

var root_reference = 'placeholder root';

function error_report(error, serialize, reference) {
    var report = {
        type : 'error',
        reference : reference,
        data : error.toString()
    };
    if (serialize) report = JSON.stringify(report);
    return report;
}

//  handle request over JSON protocol
function JSONprotocol(context, respond, external_requester) {
    //  TODO: gaurd against circular reference
    context.respond = respond;
    function send(response) {respond.call(context, '"""' + response);}
    return function (data) {
        //  sometimes multiple writes are lumped into data
        //  """ cannot occur in JSON so we append it to all
        //  JSON requests
        var operations = (data + '').split('"""');
        while (operations.length) {
            var operation = operations.shift();
            if (operation != '') {
                process_operation(context, operation, send, external_requester);
            }
        }
    }
}

function process_operation(context, operation, send, external_requester) {
    try {
        var operation = JSON.parse(operation);
        if (operation.token === undefined) {
            operation.token = getTime() + '';
        }
        if (external_requester) {
            //  a reference lookup from an external
            //  requester must initialize a requester list
            //  so we can start with a trusted list
            operation.requesters = [external_requester];
        }
        //  if response waiting for token, execute response callback
        //  TODO: make this robust against requests that
        //        legitimately need to return to previous
        //        servers to resolve. ex: reference chain
        if (responses[operation.token]) {
            responses[operation.token](null, operation);
            delete responses[operation.token];
        }
        else {
            resolve_and_execute(context, operation, function (error, value) {
                if (error) {
                    var error_rep = error_report(error, false, operation.reference);
                    error_rep.token = operation.token;
                    send(JSON.stringify(error_rep));
                }
                else {
                    value.token = operation.token;
                    send(JSON.stringify(value));
                }
            });
        }
    }
    catch (error) {
        throw error;
        send(error_report(error, true, JSON.data + ''));
    }
}


//  all open connections, to the references they are watching
var connections_watching = new Map();
//  reference hashes to connections that are watching them
var watched_references = {};

function close_connection(connection) {
    //  TODO: send unwatch to connections that started watching because of this connection
    return function () {
        //  clean up this connection's references
        var watching = connections_watching.get(connection);
        for (var i=0; i<watching.length; i++) {
            var connections = watched_references[watching[i]];
            for (var j=0; j<connections.length; j++) {
                if (connections[j] == connection) {
                    connections.splice(j,1);
                    if (connections.length == 0) {
                        delete watched_references[watching[i]];
                    }
                    break;
                }
            }
        }
        connections_watching.delete(connection);
    }
}

function handleWS(connection) {
    //  TODO: set proper requester
    var requester = 'external websocket (client) requester';
    var respond = JSONprotocol(connection, connection.send, requester);

    connections_watching.set(connection, []);

    connection.on('message', respond);
    connection.on('close', close_connection(connection));
}

function handleTCP(connection) {
    //  TODO: set proper requester (will be another persist instance)
    var requester = 'external tcp (persist) requester';
    var respond = JSONprotocol(connection, connection.write, requester);

    connections_watching.set(connection, []);

    connection.on('data', respond);
    connection.on('end', close_connection(connection));
}

//  does an expectation for a value meet the actual value
function expectation_met(expectation, value) {
    var type = get_type(value);
    var met = false;
    //  undefined expectations are always met
    if (expectation === undefined) {
        met = true;
    }
    else if (type == 'string') {
        met = value === expectation.data;
    }
    else if (type == 'function') {
        met = value.toString() == expectation.data;
    }
    else if (type == 'boolean') {
        met = value == expectation.data;
    }
    else if (type == 'null') {
        met = expectation.type == 'null';
    }
    else if (type == 'number') {
       met = expectation.data == value;
    }
    else if (type == 'reference') {
        //  TODO: compare reference strategy
    }
    else if (type == 'file') {
        //  TODO: compare file strategy
    }
    else {
        met = value === undefined && expectation.type == 'undefined';
    }
    return met;
}

//  take a serializable value and ble
function instance_from_serializable(value) {
    var unserialized;
    //  TODO: if value.data has unexpected form
    //        for type, throw an error
    if (value.type == 'string') {
        unserialized = value.data;
    }
    else if (value.type == 'function') {
        //  expose the toolbox to all users
        unserialized = scoped(value.data, toolbox);
    }
    else if (value.type == 'boolean') {
        unserialized = value.data;
    }
    else if (value.type == 'null') {
        unserialized = null;
    }
    else if (value.type == 'number') {
        unserialized = value.data;
    }
    else if (value.type == 'reference') {
        unserialized = new Reference(value.data);
    }
    else if (value.type == 'file') {
        unserialized = new File(value.data);
    }
    else if (value.type == 'undefined') {
        unserialized = undefined;
    }
    else {
        throw new Error('cannot unserialize type: ' + value.type);
    }
    return unserialized;
}

function resolve_and_execute(context, operation, callback) {
    // TODO: add followed path portion to reference so we
    //       can check circular references between processes
    // TODO: check authorization of requesters in reference
    var reference = operation.reference;
    var value = proxies[reference.id];
    if (value) {
        var value_parent = null;
        if (reference.internal) {
            var internal = reference.internal.split('.');
            value_parent = reference.id;
            while (internal.length) {
                var type = get_type(value);
                if (type == 'hashmap' || type == 'list') {
                    value_parent = meta.get(value).id;
                    value = value[internal.shift()];
                    if (value === undefined && internal.length) {
                        callback('invalid reference');
                        return;
                    }
                }
                else if (type == 'reference') {
                    resolve_and_execute(context, {
                        type : operation.type,
                        reference : {
                            id       : value.id,
                            internal : internal.join('.')
                        },
                        token : operation.token,
                        requesters : reference.requesters.concat([root_name]),
                        path       : reference.path.concat([])
                    }, callback);
                    return;
                }
            }
        }
        //  perform proper operation
        if (operation.type == 'source reference') {
            var ref_str = reference.id;
            if (value == undefined) callback('invalid reference');
            else serializable(value, reference, function (err, res) {
                if (err) callback(err);
                else {
                    res.token = operation.token;
                    callback(null, res);
                }
            });
        }
        else if (operation.type == 'evaluate') {
            //  if value is function, execute and return
            var type = get_type(value);
            if (type == 'hashmap') {
                var fn = scoped("function () {return (" + operation.script + ")}");
                var returned = fn.apply(value);
                var res = {
                    type : "success",
                    token : operation.token,
                    reference : reference,
                    value : serializable(returned)
                };
                callback(null, res);
            }
            else {
                callback('scripts must be evaluated in the context of a persistant object');
            }
        }
        else if (operation.type == 'set') {
            if (expectation_met(operation.expected, value)) {
                var parent_reference = operation.reference.internal.split('.').pop();
                var new_value = instance_from_serializable(operation.value);
                var parent = proxies[value_parent];
                parent[parent_reference] = new_value;
                callback(null, {
                    type      : 'success',
                    reference : reference,
                    token     : operation.token
                });
            }
            else {
                callback(null, {
                    type : 'error',
                    reference : reference,
                    token     : operation.token,
                    data : 'expected value before set did not match'
                });
            }
        }
        //  watch operations must be passed to the proper server 
        else if (operation.type == 'watch') {
            //  TODO: enforce value is container type (hashmap, list, map...)
            console.log(reference);
            var hashed_ref = hash_reference(reference);
            var watching = connections_watching.get(context);
            var already_watching = false;
            for (var i=0; i<watching.length; i++) {
                if (watching[i] == hashed_ref) {
                    already_watching = true;
                    break;
                }
            }
            if (already_watching) {
                callback('already watching that reference');
            }
            else {
                watching.push(hashed_ref);
                if (watched_references[hashed_ref] === undefined) {
                    watched_references[hashed_ref] = [];
                }
                //  TODO: attach connection that opened to watch to watched, not context
                watched_references[hashed_ref].push(context);

                callback(null, {
                    type : 'success',
                    reference : reference,
                    token : operation.token
                });
            }
        }
        else if (operation.type == 'update') {
            send_to_watching(context, reference, value);
        }
        else callback('invalid operation type: ' + operation.type);
    }
    else resolve_and_execute_external(context, operation, callback);
}

function hash_reference(reference) {
    var id = reference.id;
    var internal = '';
    if (reference.internal) {
        internal = '.' + reference.internal;
    }
    return id + internal;
}

function unhash_reference(hashed_reference) {
    var id = hashed_reference.split('.').shift();
    var internal = hashed_reference.substr
    return {
        id : id,
        internal : internal
    };
}

var connections = {};
var responses = {};

function resolve_and_execute_external(context, operation, callback) {
     host_resolver(operation.reference.id, function (err, data) {
         if (operation.type == 'watch') {
             var hashed_ref = hash_reference(operation.reference);
             if (watched_references[hashed_ref] === undefined) {
                 watched_references[hashed_ref] = [];
             }
             watched_references[hashed_ref].push(context);
         }
        if (err) callback('error occurred resolving host for reference');
        else if (data) {
            //  make TCP request to proper host
            var host_reference = data.host + ':' + data.port;
            if (connections[host_reference] == undefined) {
                var client = net.connect(data.port, data.host, function () {
                    client.write('"""' + JSON.stringify(operation));
                });
                var external_requester = 'value for external requester';
                client.on('data', JSONprotocol(client, client.write, external_requester));
                client.on('end', function () {
                    //  TODO: clean up connections
                });
                connections[host_reference] = client;
            }
            else {
                connections[host_reference].write('"""' + JSON.stringify(operation));
            }
            responses[operation.token] = callback;
        }
        else callback('could not resolve host for reference');
    });
}

function serializable(value, reference, callback) {
        var type = get_type(value);
        var serializable = {};
        serializable.type = type;
        serializable.reference = reference;
        if (type == 'hashmap') {
            serializable.data = {};
            var id = meta.get(value).id;
            for (var field in value) {
                serializable.data[field] = {
                    id       : id,
                    internal : field
                };
            }
        }
        else if (type == 'string' || type == 'boolean' || type == 'null' || type == 'number') {
            serializable.data = value;
        }
        else if (type == 'reference') {
            serializable.data = 'reference...';
        }
        else if (type == 'file') {
            serializable.data = 'file...';
        }
        else if (type == 'function') {
            serializable.data = value.toString();
        }
        else if (value === undefined) {
            
        }
        else {
            var msg = value + ' is not serializable';
            if (callback) callback(msg);
            else throw new Error(msg);
            return;
        }
        if (callback) callback(null, serializable);
        else return serializable;
}
function isNumber(value) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}

function save_record(record) {
    var id = record.id;
    var pending = meta.get(proxies[id]).pending_records;
    pending.push(record);
}

function persist_records(proxy) {
    function next() {
        setTimeout(function () {
            persist_records(proxy);
        }, PERSIST_RECORD_DELAY);
    }

    var state = meta.get(proxy);
    var pending = state.pending_records;

    if (pending.length) {
        var data = '';
        while (pending.length) {
            var s = JSON.stringify(pending.shift());
            data += '\n' + s;
        }
        fs.appendFile('/persist/' + state.id, data, function (err) {
            if (err) console.log(err);
            next();
        });
    }
    else if (state.unloading) state.onunload();
    else                      next();
}

function lock(id, callback) {
    //  lock policy handled outside of this module
    callback(null);
}

function unlock(persistant, callback) {
    //  lock and unlock policy handled outside of this module
    callback(null)
}

function get_type(val) {
    if      (typeof val == 'string'  ) return 'string';
    else if (typeof val == 'number'  ) return 'number';
    else if (typeof val == 'boolean' ) return 'boolean';
    else if (typeof val == 'function') return 'function';
    else if (typeof val == 'date'    ) return 'date';
    else if (val === null            ) return 'null';
    else if (meta.has(val)           ) return meta.get(val).type;
    else if (val instanceof File     ) return 'file';
    else if (references.is(val)      ) return 'reference';
    else if (val == undefined        ) return 'undefined';
    else return undefined;
}

function send_to_watching(context, reference, value) {
    var hashed_ref = hash_reference(reference);
    var watching = watched_references[hashed_ref];
    if (watching) {
        serializable(value, reference, function (err, res) {
            if (err) console.log(err);
            else {
                //  TODO: send original time along
                var update = JSON.stringify({
                    type : 'update',
                    reference : reference,
                    time : getTime(),
                    value : res,
                    token : getTime()
                });
                console.log(watching.length);
                for (var i=0; i<watching.length; i++) {
                    //  if context is also watching this reference, it does not need to receive the update
                    if (context != watching[i]) {
                        console.log('hmmmmm');
                        watching[i].respond.call(watching[i], update);
                    }
                }
            }
        });
    }
}

function get_persistant_proxy(id) {
    var hash = {};

    function set_field(target, field, val, receiver) {
        var type = meta.get(proxy).type;

        var LIST = type == 'list';
        var HASH = type == 'hashmap';

        if (LIST && !isNumber(field)) {
            throw new Error('arrays are only indexed with numeric values');
        }

        var type = get_type(val);
        var persistant = meta.has(val)

        //  type will be undefined for a loading persistant object
        //  checking meta ensures persistant objects are allowed
        if (persistant || type) {
            var time = getTime();
            var operation = 'set';
            var value = val + '';

            if (persistant) {
                value = meta.get(val).id;
                meta.get(proxy).dependencies.push(val);
            }
            else if (type == 'function') {
                val = scoped(value);
            }
            else if (type == 'file')      value = value.url;
            else if (type == 'reference') value = value.path;

            if (meta.get(proxy).loaded) {
                save_record({
                    time      : time,
                    id        : id,
                    operation : operation,
                    field     : field,
                    type      : type,
                    value     : value
                });
            }
            if (LIST) {
                list[field] = val;
            }
            else if (HASH) {
                if (val !== undefined) hash[field] = val;
                else delete hash[field];
            }
            var reference = {
                id : id,
                internal : field
            };
            send_to_watching(null, reference, val);
        }
        else {
            throw new Error((typeof val) + ' not supported in persistant object');
        }
    }

    var proxy = Proxy.create({
        getOwnPropertyDescriptor : function (target, name) {
            return hash[name];
        },
        getOwnPropertyNames : function (target) {
            var properties = [];
            for (var property in hash) {
                if (hash.hasOwnProperty(property)) {
                    properties.push(property);
                }
            }
            return properties;
        },
        delete : function (name) {
            delete hash[name];
        },
        freeze : function () {},
        seal : function () {},
        preventExtensions : function () {},
        has : function () {},
        hasOwn : function () {},
        get : function (target, name, receiver) {
            return hash[name];
        },
        set : set_field,
        enumerate : function (target) {
            var properties = [];
            for (var property in hash) {
                if (hash.hasOwnProperty(property)) {
                    properties.push(property);
                }
            }
            return properties;
        },
        keys : function (target) {
            var properties = [];
            for (var property in hash) {
                if (hash.hasOwnProperty(property)) {
                    properties.push(property);
                }
            }
            return properties;
        },
        apply : function () {},
        construct : function () {}
    });

    meta.set(proxy, {
        id              : id,
        hash            : hash,
        loaded          : false,
        unloading       : false,
        pending_records : [],
        dependencies    : [],
        onload          : [],
    });

    proxies[id] = proxy;

    persist_records(proxy);

    trigger('control', id);

    return proxy;
}

function scoped(expression) {
    var context = toolbox;
    vm.runInNewContext('var _tmp_ = ' + expression, context);
    var value = context._tmp_;
    delete context._tmp;
    return value;
}

var valid_types = {
    'hashmap' : true,
    'list' : true
};

function create(type, id) {
    if (valid_types[type] === undefined) {
        throw new Error('"' + type + '" is not a valid type');
    }

    //  creates persistant object of type with a new id
    if (id === undefined) id = getTime() + '';

    var proxy = get_persistant_proxy(id);
    save_record({
        time      : getTime(),
        id        : id,
        operation : 'create',
        field     : 'type',
        type      : type,
        value     : type
    });
    lock(id, function (err, res) {
        if (err) console.log(err);
    });
    meta.get(proxy).loaded = true;
    meta.get(proxy).type = type;
    return proxy;
}

function identify(persistant) {
    if (meta.has(persistant)) {
        return meta.get(persistant).id;
    }
    else {
        throw new Error('cannot identify non-persistant item');
    }
}

function load(id, callback) {
    var proxy = proxies[id];
    if (proxy) {
        if (meta.get(proxy).loaded) {
            if (callback) callback(null, proxies[id]);
        }
        else if (callback) {
            meta.get(proxy).onload.push(callback);
        }
        return proxy;
    }

    if (typeof id != 'string') throw new Error('get requires id');

    var proxy = get_persistant_proxy(id);

    if (callback) meta.get(proxy).onload.push(callback);

    function load_records() {
        //  load this proxy's history to get current state
        fs.readFile('/persist/' + id, function (err, res) {
            if (err) {
                callback(err);
                return;
            }
            function handle_record(record) {
                var type = record.type;
                if (record.operation == 'create') {
                    meta.get(proxy).type = type;
                    return;
                }
                var value = record.value;

                if      (type == 'boolean'  ) value = value === 'true';
                else if (type == 'null'     ) value = null;
                else if (type == 'number'   ) value = parseFloat(value);
                else if (type == 'function' ) value = scoped(value);
                else if (type == 'file'     ) value = new File(value);
                else if (type == 'reference') value = new Reference(value);
                else if (type == 'hashmap' || type == 'list') {
                    value = load(value, check_done);
                }
                else if (type == 'undefined') value = undefined;
                if (value) proxy[record.field] = value;
                else       delete proxy[record.field];
            }
            var data = res.toString();
            var records = data.split('\n');
            records.shift(); // first == ''
            while (records.length) {
                handle_record(JSON.parse(records.shift()));
            }
            meta.get(proxy).loaded = true;
            var done = false;
            function check_done() {
                if (done) return;
                var dependencies = meta.get(proxy).dependencies;
                for (var i = 0; i < dependencies.length; i++) {
                    if(!meta.get(dependencies[i]).loaded) return;
                }
                done = true;
                var onload = meta.get(proxy).onload;
                for (var i = 0; i < onload.length; i++) {
                    onload[i](null, proxy);
                }
            }
            check_done();
        });
    }

    lock(id, function (err, res) {
        if (err) console.log(err);
        else     load_records();
    });
    return proxy;
}

function is(proxy) {
    return meta.has(proxy);
}

function unload(proxy, callback) {
    if (!meta.has(proxy)) {
        throw new Error('cannot unload non persistant item');
    }
    else if (meta.get(proxy).unloading) {
        throw new Error('already unloading');
    }

    var id   = meta.get(proxy).id;
    var deps = meta.get(proxy).dependencies;
 
    meta.get(proxy).unloading = true;

    var todo = 1;
    function done(err) {
        if (err) console.log(err);
        else     todo -= 1;
        
        if (todo == 0 && callback) callback(null);
    }

    for (var i=0; i<deps.length; i++) {
        if (meta.has(deps[i]) && !meta.get(deps[i]).unloading) {
            todo += 1;
            unload(deps[i], done);
        }
    }

    meta.get(proxy).onunload = function () {
        meta.delete(proxy);
        delete proxies[id];
        unlock(id, done);
    }
}

function resolve_hosts(resolver) {
    //  resolver is a function that takes an id and
    //  calls back with error or a host that owns the
    //  given id
    host_resolver = resolver;
}

//  TODO: serve historical version of object
