//  process must be started with --harmony flag
var vm = require('vm');
var dynamodb = require('aws').dynamodb;
var Promise = require('promise');
var files = require('files');
var references = require('./references.js');

module.exports.handleWS   = handleWS;
module.exports.handleTCP  = handleTCP;
module.exports.identify   = identify;
module.exports.create     = create;
module.exports.unload     = unload;
module.exports.load       = load;
module.exports.host       = host;
module.exports.is         = is;

function error_report(error, serialize, reference) {
    var report = {
        type : 'error',
        reference : reference,
        data : error.toString()
    };
    if (serialize) report = JSON.stringify(report);
    return report;
}

//  handle request over JSON protocol
function JSONprotocol(context, respond) {
    // call given respond function in context with response
    function send(response) {respond.call(context, response);}
    return function (data) {
        //  TODO: handle set operations
        //  TODO: handle function call
        try {
            var info = JSON.parse(data);
            serializable(info, function (error, response) {
                if (error) send(error_report(error, true, info));
                else       send(JSON.stringify(response));
            });
        }
        catch (error) {
            send(error_report(error, true, info));
        }
    }
}

function handleWS(connection) {
    var respond = JSONprotocol(connection, connection.send);
    connection.on('message', respond);
    connection.on('close', function () {});
}

function handleTCP(connection) {
    var respond = JSONprotocol(connection, connection.write);
    connection.on('data', respond);
    connection.on('end', function () {});
}


function serializable(reference, callback) {
    // TODO: add followed path portion to reference so we
    //       can check circular references between processes
    var value = proxies[reference.id];
    if (value)  {
        if (reference.internal) {
            var internal = reference.internal.split('.');
            while (internal.length) {
                var type = get_type(value);
                var valid_types = {
                    hashmap : true,
                    list : true
                };
                if (valid_types[type]) {
                    value = value[internal.shift()];
                    if (value === undefined) {
                        callback(null, {
                            type : 'error',
                            reference : reference, 
                            data : 'invalid reference'
                        });
                        return;
                    }
                }
                else if (type == 'reference') {
                    var ref = {
                        id       : value.id,
                        internal : internal.join('.')
                    };
                    host(ref, function (err, hostname) {
                        if (err) callback('could not resolve host for reference');
                        else {
                            //  make TCP request to proper host
                            //  TODO: if this is the host, skip tcp
                            var client = net.connect({
                                host : hostname
                            }, function () {
                                client.write(JSON.stringify(ref));
                            });
                            client.on('data', function (data) {
                                callback(null, JSON.parse(data));
                                client.end();
                            });
                        }
                    })
                    return;
                }
            }
        }
        var type = get_type(value);
        var returnable = {};
        returnable.type = type;
        returnable.reference = reference;
        if (type == 'hashmap') {
            returnable.data = {};
            var id = meta.get(value).id;
            for (var field in value) {
                returnable.data[field] = {
                    id : id,
                    internal : field
                };
            }
        }
        else if (type == 'string' || type == 'boolean' || type == 'null' || type == 'number') {
            returnable.data = value;
        }
        else if (type == 'reference') {
            returnable.data = 'reference...';
        }
        else if (type == 'file') {
            returnable.data = 'file...';
        }
        else if (type == 'function') {
            returnable.data = value.toString();
        }
        else {
            throw new Error(value + ' is not serializable');
        }
        callback(null, returnable);
    }
    else {
        callback('request sent to host without object');
    }
}

var File = files.file;
var Reference = references.reference;

var meta = new Map();
var proxies = {};

var begin      = (new Date()).getTime() * 1e6;
var first_time = process.hrtime();

function getTime() {
    var elapsed = process.hrtime(first_time);
    return begin + elapsed[0] * 1e9 + elapsed[1];
}

var PROCESS_ID = getTime() + Math.random() + '';
var PERSIST_RECORD_DELAY = 100;

function isNumber(value) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}


function save_record(record) {
    var id = record.id;
    var pending = meta.get(proxies[id]).pending_records;
    pending.push(record);
}

function persist_records(proxy) {
    function next() {
        setTimeout(function () {
            persist_records(proxy);
        }, PERSIST_RECORD_DELAY);
    }

    var state = meta.get(proxy);
    var pending = state.pending_records;

    if (pending.length) {
        var records = [];
        for (var i=0; i<pending.length; i++) {
            var record = pending[i];
            var id = record.id;
            var item = {
                time      : {N : record.time      + ''},
                id        : {S : record.id        + ''},
                operation : {S : record.operation + ''},
                field     : {S : record.field     + ''},
                type      : {S : record.type      + ''},
                value     : {S : record.value     + ''}
            };
            records.push({ PutRequest : { Item : item } });
        }

        var params = {
            RequestItems : { 'persist' : records }
        };

        //  TODO: use s3
        dynamodb.batchWriteItem(params, function (err, res) {
            if (err) console.log(err);
            else {
                pending.splice(0, records.length);
                next();
            }
        });
    }
    else if (state.unloading) state.onunload();
    else next();
}

function lock(id, callback) {
    var params = {
        TableName : 'locks',
        Item : {
            time       : {N : getTime() + ''},
            id         : {S : id            },
            process    : {S : PROCESS_ID    }
        },
        Expected : { persistant : { Exists : false } }
    };

    //  TODO: use synchronizing process
    dynamodb.putItem(params, function (err, res) {
        if (callback) callback(err);
    });
}

function unlock(persistant, callback) {
    var params = {
        TableName : 'locks',
        Key : {
            id      : {'S' : persistant},
            process : {'S' : PROCESS_ID}
        }
    };

    // TODO: use synchronizing process
    dynamodb.deleteItem(params, function (err, res) {
        if (callback) callback(err);
    });

}

function get_type(val) {
    if      (typeof val == 'string'  ) return 'string';
    else if (typeof val == 'number'  ) return 'number';
    else if (typeof val == 'boolean' ) return 'boolean';
    else if (typeof val == 'function') return 'function';
    else if (typeof val == 'date'    ) return 'date';
    else if (val === null            ) return 'null';
    else if (meta.has(val)           ) return meta.get(val).type;
    else if (val instanceof File     ) return 'file';
    else if (references.is(val)      ) return 'reference';
    else return undefined;
}

function get_persistant_proxy(id, context) {
    var hash = {};

    function set_field(target, field, val, receiver) {
        var type = meta.get(proxy).type;

        var LIST = type == 'list';
        var HASH = type == 'hashmap';

        if (LIST && !isNumber(field)) {
            throw new Error('arrays are only indexed with numeric values');
        }

        var type = get_type(val);
        var persistant = meta.has(val)

        //  type will be undefined for a loading persistant object
        //  checking meta ensures persistant objects are allowed
        if (persistant || type) {
            var time = getTime();
            var operation = 'set';
            var value = val + '';

            if (persistant) {
                value = meta.get(val).id;
                meta.get(proxy).dependencies.push(val);
            }
            else if (type == 'function') {
                val = scoped(value, context);
            }
            else if (type == 'file')      value = value.url;
            else if (type == 'reference') value = value.path;

            if (meta.get(proxy).loaded) {
                save_record({
                    time      : time,
                    id        : id,
                    operation : operation,
                    field     : field,
                    type      : type,
                    value     : value
                });
            }
            if      (LIST) list[field] = val;
            else if (HASH) hash[field] = val;
        }
        else {
            throw new Error((typeof val) + ' not supported in persistant object');
        }
    }

    var proxy = Proxy.create({
        getOwnPropertyDescriptor : function (target, name) {
            return hash[name];
        },
        getOwnPropertyNames : function (target) {
            var properties = [];
            for (var property in hash) {
                if (hash.hasOwnProperty(property)) {
                    properties.push(property);
                }
            }
            return properties;
        },
        delete : function (name) {
            delete hash[name];
        },
        freeze : function () {},
        seal : function () {},
        preventExtensions : function () {},
        has : function () {},
        hasOwn : function () {},
        get : function (target, name, receiver) {
            return hash[name];
        },
        set : set_field,
        enumerate : function (target) {
            var properties = [];
            for (var property in hash) {
                if (hash.hasOwnProperty(property)) {
                    properties.push(property);
                }
            }
            return properties;
        },
        keys : function (target) {
            var properties = [];
            for (var property in hash) {
                if (hash.hasOwnProperty(property)) {
                    properties.push(property);
                }
            }
            return properties;
        },
        apply : function () {},
        construct : function () {}
    });

    meta.set(proxy, {
        id : id,
        hash : hash,
        loaded : false,
        unloading : false,
        pending_records : [],
        dependencies : [],
        onload : [],
    });

    proxies[id] = proxy;

    persist_records(proxy);

    return proxy;
}

function scoped(expression, context) {
    vm.runInNewContext('var _tmp_ = ' + expression, context);
    var value = context._tmp_;
    delete context._tmp;
    return value;
}

var valid_types = {
    'hashmap' : true,
    'list' : true
};

function create(type, context) {
    if (context === undefined) context = {};
    else if (typeof context !== 'object') {
        throw new Error('context must be object');
    }
    if (valid_types[type] === undefined) {
        throw new Error('"' + type + '" is not a valid type');
    }

    //  creates persistant object of type with a new id
    var id = getTime() + '';

    var proxy = get_persistant_proxy(id, context);
    save_record({
        time      : getTime(),
        id        : id,
        operation : 'create',
        field     : 'type',
        type      : type,
        value     : type
    });
    lock(id, function (err, res) {
        if (err) console.log(err);
    });
    meta.get(proxy).loaded = true;
    meta.get(proxy).type = type;
    return proxy;
}

function identify(persistant) {
    if (meta.has(persistant)) {
        return meta.get(persistant).id;
    }
    else {
        throw new Error('cannot identify non-persistant item');
    }
}

function load(id, context, callback) {
    var proxy = proxies[id];
    if (proxy) {
        if (meta.get(proxy).loaded) {
            if (callback) callback(null, proxies[id]);
        }
        else if (callback) {
            meta.get(proxy).onload.push(callback);
        }
        return proxy;
    }

    if (context === undefined) context = {};
    else if (typeof context !== 'object') {
        throw new Error('context must be object not ' + (typeof context));
    }
    if (typeof id != 'string') throw new Error('get requires id');

    var proxy = get_persistant_proxy(id, context);

    if (callback) meta.get(proxy).onload.push(callback);

    function query() {
        //  load this proxy's history to get current state
        //  TODO: use s3
        dynamodb.query({
            TableName : 'persist',
            Select : 'ALL_ATTRIBUTES',
            KeyConditions : {
                id : {
                    ComparisonOperator : 'EQ',
                    AttributeValueList : [{S : id}]
                }
            }
        }, function (err, res) {
            if (err) {
                callback(err);
                return;
            }
            function handle_record(operation, field, type, value) {
                if (operation == 'create') {
                    meta.get(proxy).type = type;
                    return;
                }
                var BOOLEAN    = type == 'boolean';
                var NULL       = type == 'null';
                var NUMBER     = type == 'number';
                var FUNCTION   = type == 'function';
                var PERSISTANT = type == 'hashmap' || type == 'list';
                var FILE       = type == 'file';
                var REFERENCE  = type == 'reference';
                if      (BOOLEAN)   value = value === 'true';
                else if (NULL)      value = null;
                else if (NUMBER)    value = parseFloat(value);
                else if (FUNCTION)  value = scoped(value, context);
                else if (FILE)      value = new File(value);
                else if (REFERENCE) value = new Reference(value);
                else if (PERSISTANT) {
                    value = load(value, context, check_done);
                }
                proxy[field] = value;
            }
            for (var i = 0; i < res.Items.length; i++) {
                var item      = res.Items[i];
                var operation = item.operation.S; 
                var field     = item.field.S;
                var type      = item.type.S;
                var value     = item.value.S;
                handle_record(operation, field, type, value);
            }
            meta.get(proxy).loaded = true;
            var done = false;
            function check_done() {
                if (done) return;
                var dependencies = meta.get(proxy).dependencies;
                for (var i = 0; i < dependencies.length; i++) {
                    if(!meta.get(dependencies[i]).loaded) return;
                }
                done = true;
                var onload = meta.get(proxy).onload;
                for (var i = 0; i < onload.length; i++) {
                    onload[i](null, proxy);
                }
            }
            check_done();
        });
    }

    lock(id, function (err, res) {
        if (err) console.log(err);
        else query();
    });
    return proxy;
}

function is(proxy) {
    return meta.has(proxy);
}

function unload(proxy, callback) {
    if (!meta.has(proxy)) {
        throw new Error('cannot unload non persistant item');
    }
    else if (meta.get(proxy).unloading) {
        throw new Error('already unloading');
    }

    var id = meta.get(proxy).id;
    var deps = meta.get(proxy).dependencies;
 
    meta.get(proxy).unloading = true;

    var todo = 1;
    function done(err) {
        if (err) console.log(err);
        else     todo -= 1;
        
        if (todo == 0 && callback) callback(null);
    }

    for (var i=0; i<deps.length; i++) {
        if (meta.has(deps[i]) && !meta.get(deps[i]).unloading) {
            todo += 1;
            unload(deps[i], done);
        }
    }

    meta.get(proxy).onunload = function () {
        meta.delete(proxy);
        delete proxies[id];
        unlock(id, done);
    }
}

function host(reference) {
    //  TODO: get host of reference from synchronizer host
    return new Promise(function (resolve, reject) {
        resolve('localhost');
    });
}
