var get_time = require('./get_time');
var responses = require('./responses');
var resolve_and_execute = require('./resolve_and_execute');
var error_report = require('./error_report');

module.exports = JSONprotocol;


//  handle request over JSON protocol
function JSONprotocol(context, respond, external_requester) {
    //  TODO: gaurd against circular reference
    context.respond = respond;
    function send(response) {respond.call(context, '"""' + response);}
    return function (data) {
        //  sometimes multiple writes are lumped into data
        //  """ cannot occur in JSON so we append it to all
        //  JSON requests
        var operations = (data + '').split('"""');
        while (operations.length) {
            var operation = operations.shift();
            if (operation != '') {
                process_operation(context, operation, send, external_requester);
            }
        }
    }
}

var client_tokens = {};

function process_operation(context, operation, send, external_requester) {
    try {
        operation = JSON.parse(operation);

        if (external_requester) {
            //  a reference lookup from an external
            //  requester must initialize a requester list
            //  so we can start with a trusted list
            operation.requesters = [external_requester];
        }
        //  if response waiting for token, execute response callback
        //  TODO: make this robust against requests that
        //        legitimately need to return to previous
        //        servers to resolve. ex: reference chain
        if (responses[operation.token]) {
            responses[operation.token](null, operation);
            delete responses[operation.token];
        }
        else {
            resolve_and_execute(context, operation, function (error, value) {
                if (error) {
                    value = error_report(error, false, operation.reference);
                }
                value.token = operation.token;
                send(JSON.stringify(value));
            });
        }
    }
    catch (error) {
        console.log(operation);
        var error_rep = error_report(error, true, JSON.data + '');
        error_rep.token = operation.token;
        send(error_rep);
    }
}


